<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>前端路上</title>
    <link>https://refined-x.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>原创前端技术博客，致力于分享前端学习路上的第一手资料。专注web前端开发、移动端开发、前端工程化、前端职业发展，做最有价值的前端技术学习网站。</description>
    <pubDate>Mon, 16 Dec 2019 06:52:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>搬砖狗年度好物推荐-《职场的真相》</title>
      <link>https://refined-x.com/2019/12/16/2019-good-lesson/</link>
      <guid>https://refined-x.com/2019/12/16/2019-good-lesson/</guid>
      <pubDate>Mon, 16 Dec 2019 06:45:04 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;今年下半年换了个团队，建制还不完整，忙的一逼，博客也有一阵子没时间更新了。&lt;/p&gt;
&lt;p&gt;虽然我们常说忙点总比不忙好，但忙这件事也有边际效应，比如最近我就感受很深，一个人当三个人使，忙的底儿掉，但我的能力会因此等比增长吗？肯定不会，因为没有时间思考，没有时间复盘，这种程度的
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>今年下半年换了个团队，建制还不完整，忙的一逼，博客也有一阵子没时间更新了。</p><p>虽然我们常说忙点总比不忙好，但忙这件事也有边际效应，比如最近我就感受很深，一个人当三个人使，忙的底儿掉，但我的能力会因此等比增长吗？肯定不会，因为没有时间思考，没有时间复盘，这种程度的忙，从个人成长的角度早已达到了收益边际，超出的部分完全是不计回报的，可以算是放眼未来的一种风险投资吧。</p><p><strong>那么问题来了，这种投入值不值？</strong></p><p>我发现但凡工作过五六年以上的，大部分人都已经对这种职场问题有了自己的答案，这些答案都是我们根据自己所见所闻总结出来的，从个体角度讲，这些当然是经过实践检验的“真相”，但我们也很清楚，这些仅仅是我们自己的小范围实践，那么放眼整个商业社会，什么才是真相呢？</p><p>这种问题必须跳出自己的圈子，去更大的范围里找答案，现在已经年底了，很多IT人都有做年终总结的习惯，我们如雷贯耳的caoz大神则推出了年度课程《职场的真相》，从历史数据来看，他这门每年一次的课程是整个IT圈里为数不多的干货，值得我们这些晚辈搬个小板凳好好的听一听。</p><p>搬了一年的砖，如果一定要奖励自己点什么，我觉得花钱开眼界是个不错的选择。</p><p>《职场的真相》大体的目录列一下，最终可能还会有调整。</p><ol><li>关于面试的话题 </li><li>什么是职场的态度 </li><li>职场信任关系是如何产生的 </li><li>如何面对不公平 </li><li>晋升的秘密 </li><li>企业永远不是家</li><li>所谓副业的话题 </li><li>职场切忌自作聪明</li></ol><p><img src="https://frontend-weekly.com/img/a/%E8%81%8C%E5%9C%BA%E7%9A%84%E7%9C%9F%E7%9B%B8.jpg" alt=""></p><p>对了，课程2019-12-20号开课，之后不提供回放，过期后想买也买不到了，截止发文当天，只有四天时间，你还犹豫吗？</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/12/16/2019-good-lesson/#disqus_thread</comments>
    </item>
    
    <item>
      <title>阿里P7前端高级工程师，都需要掌握哪些技术栈？</title>
      <link>https://refined-x.com/2019/08/02/vip-kaikeba-vue-lesson/</link>
      <guid>https://refined-x.com/2019/08/02/vip-kaikeba-vue-lesson/</guid>
      <pubDate>Fri, 02 Aug 2019 07:17:30 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;大家都知道，阿里P7前端高级工程师，基本上是一线前端技术人能达到的最高职级，也是很多程序员追求的目标。达到年薪50W+股票的P7级别，不仅要具备优秀的编程能力，在系统设计能力和技术视野方面，也要有较深的积淀。
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>大家都知道，阿里P7前端高级工程师，基本上是一线前端技术人能达到的最高职级，也是很多程序员追求的目标。达到年薪50W+股票的P7级别，不仅要具备优秀的编程能力，在系统设计能力和技术视野方面，也要有较深的积淀。 </p><p>最近技术大牛<strong>廖雪峰</strong>邀请他一位在阿里做前端架构师的朋友，整理出一份xmind——“Web全栈架构师所需技术栈”，对于需要提升技术能力的初中级前端程序员们，提供一些学习方向上的借鉴和参考。 </p><p><img src="/asset/a/vip-kaikeba-vue-lesson-1.png" alt=""><br><img src="/asset/a/vip-kaikeba-vue-lesson-2.png" alt=""></p><p>除去 xmind 外，还额外分享一套vip视频，廖雪峰联合一位精通 Vue / React / 前端工程化(源码级)的百度前端架构师Dyson，专门选取了 <strong>Vue源码</strong> 和 <strong>组件设计与开发</strong> 两大难点（他擅长的方向之一就是Vue框架），经过 1个月梳理和准备录制出来的视频，一定能帮大家加深对Vue的理解和学习。 </p><p>框架变来变去，底层却还是那些东西，学习源码练好内功。vip视频分享给大家，现在可以免费观看，具体包含以下内容：</p><h2 id="Vue-源码解析"><a href="#Vue-源码解析" class="headerlink" title="Vue 源码解析"></a>Vue 源码解析</h2><p>1-Vue工作机制介绍 </p><blockquote><p>了解 Vue 的整体工作机制 </p></blockquote><p>2-响应式原理实现 </p><blockquote><p>Object.defineProperty 的用法 </p><p>理解 Vue 响应式的实现过程 </p></blockquote><p>3-依赖收集 </p><blockquote><p>了解 Vue 中是扫描视图收集依赖，当数据变化的时候进行相应视图更新 </p></blockquote><p>4-编译片段追加宿主 </p><blockquote><p>编译的过程，将编译结果追加到 html 片段 </p></blockquote><p>5-节点类型判断 </p><blockquote><p>编译过程中如何识别不同类型的元素 </p></blockquote><p>6-动态文本更新 </p><blockquote><p>Vue 中如何将视图中的插值动态文本渲染 </p></blockquote><p>7-指令匹配查找 </p><blockquote><p>识别不同的指令进行相应的操作 </p></blockquote><p>8-model双向绑定实现 </p><blockquote><p>Vue 中如何实现表单 model 的双向绑定 </p></blockquote><h2 id="深入Vue组件设计与开发"><a href="#深入Vue组件设计与开发" class="headerlink" title="深入Vue组件设计与开发"></a>深入Vue组件设计与开发</h2><p>1-组件设计理念 </p><p>2-自定义组件的双向绑定 </p><p>3-组件间通信机制 </p><p>4-插槽的使用 </p><p>5-provide &amp; inject API </p><p>实战任务：实现一个element-ui的表单组件 </p><p>相信大家看了详细内容后，已经了解到干货含量如何，这次共有<strong style="color:red">200个免费报名</strong><strong>vip视频的权限（超额之后需要付费观看）</strong>，机会难得，需要的读者朋友尽快报名～ </p><p><img src="/asset/a/vip-kaikeba-vue-lesson-3.png" alt=""></p><div style="text-align:center;color:red;font-weight:700"><br>    <div>扫描二维码 获取vip学习权限 </div><br>    <div>也可以向小助理申请xmind高清大图</div><br></div><p>通过申请后会逐个开通权限，小助手精力有限，手慢无哦~</p><p>视频的价值取决于领取后的行动，大家千万别做收藏党。和志同道合的人一起深入讨论与学习 Web前端技术，也欢迎转给需要的朋友！ </p><p>vip视频由<strong>开课吧</strong>提供，感谢开课吧一直以来的友情支持。 </p><p>开课吧：致力于打造互联网从业者职业成长平台。现在面向前端程序员，专门打磨了进阶课程<strong>《JavaScript高级工程师》</strong>和<strong>《Web全栈架构师》</strong>，帮助大家打破技术瓶颈，提高自身竞争力，实现职业的可持续成长。 </p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/08/02/vip-kaikeba-vue-lesson/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从Hexo文章置顶看需求分析思路</title>
      <link>https://refined-x.com/2019/08/02/top-article/</link>
      <guid>https://refined-x.com/2019/08/02/top-article/</guid>
      <pubDate>Fri, 02 Aug 2019 02:13:15 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;前端路上技术博客是基于Hexo构建发布的，最近需要给博客加上置顶功能，想来这种需求肯定早已经被前人充分“轮子”了，于是打开搜索引擎输入“hexo
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>前端路上技术博客是基于Hexo构建发布的，最近需要给博客加上置顶功能，想来这种需求肯定早已经被前人充分“轮子”了，于是打开搜索引擎输入“hexo 置顶”，期望看到经过时间洗礼后整齐划一的“最佳实践”。</p><p>结果稍微有一点出乎意料，又对又好的方案只有一个，看来大家都很懒，找到一个能用的自己就不折腾了，可能因为这个需求也确实简单了点，没有重复折腾的必要。</p><p>这个唯一正确的实现是<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="external">hexo-generator-index-pin-top</a>，安装插件后，只要给文章属性添加<code>top: true</code>就可以实现置顶。</p><p>但在搜索结果前十里面，还夹杂了一些错误的实现，这就有点没想到了。</p><h2 id="这些实现是错的"><a href="#这些实现是错的" class="headerlink" title="这些实现是错的"></a>这些实现是错的</h2><p>他们分别是：</p><ol><li>用排序代替置顶</li><li>不光首页置顶，翻页也置顶</li></ol><p>为什么这么简单、历史悠久的需求，搜索引擎都不能给出一致而正确的结果呢？有两种可能的解释。一，这说明长期以来像搜索引擎提出这个问题的用户中，有一部分人仍然把时间花在了那些错误的实践上，使搜索引擎认为这些错误结果仍然有参考价值；二，正确的实现仅有一个，即便拾人牙慧的文章搬运工也懒得重复抄录了，导致正确结果数量太少，搜索引擎必须顺位将其他结果也填充进来。</p><p>不管什么原因，都一定程度上说明Hexo的生态没有想象中的健康，Hexo官方插件库的搜索结果中，也有大量的垃圾插件。说到生态，可以再进一步想一个问题，为什么Vue这么容易上手？一个很重要的原因是官方对几个主要需求做了垄断，直接给最佳实践，不需要开发者自己折腾，因为折腾半天做出来的可能也是个垃圾。</p><p>再回来看看上面那两种错误实现吧。</p><h2 id="他们为什么错了"><a href="#他们为什么错了" class="headerlink" title="他们为什么错了"></a>他们为什么错了</h2><p>第一种思路，给每篇文章加一个高优先级的排序条件，比如<code>sort</code>。这样实现的置顶效果，本质上跟置顶不是一回事。置顶，顾名思义就是排第一，而排序不光可以排第一，还可以排第N，这个思路最终做出来的，其实根本不是置顶。一个小例子就可以证明，真正的置顶应该可以给置顶文章加置顶标识，而排序出来的置顶文章就没法加，因为逻辑上就没有<code>top: true</code>这样的明确标记，怎么加？</p><p>水平一般的产品经理经常犯这种错误，他们分不清什么是正确的思路，什么是只能在有限情况下暂时满足需求的思路。</p><p>第二种错误更低级，让置顶对象始终在列表顶部，无视翻页。本质是使被置顶对象脱离了原队列，直接结果就是毁灭性的破坏用户体验，每次翻页都会看到这一条，拜托，我都翻页了！</p><p>这特么压根就是一个广告位。没有任何产品思维的人才能干出这种事，希望他们永远不要尝试做产品经理。</p><h2 id="怎样避免犯这种错误"><a href="#怎样避免犯这种错误" class="headerlink" title="怎样避免犯这种错误"></a>怎样避免犯这种错误</h2><p>高手都是用时间和金钱堆出来的，多做事，多犯错。</p><p>养成归纳事物本质的习惯，思维高度是第一生产力。</p><p>说来说去还是那句话，同样优秀的人比勤奋，同样勤奋的人比优秀。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/08/02/top-article/#disqus_thread</comments>
    </item>
    
    <item>
      <title>随手开源一个微信小程序仪表盘组件</title>
      <link>https://refined-x.com/2019/07/22/weapp-plugin-dashboard/</link>
      <guid>https://refined-x.com/2019/07/22/weapp-plugin-dashboard/</guid>
      <pubDate>Mon, 22 Jul 2019 07:21:55 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;一个微信小程序仪表盘组件&quot;&gt;&lt;a href=&quot;#一个微信小程序仪表盘组件&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一个微信小程序仪表盘组件"><a href="#一个微信小程序仪表盘组件" class="headerlink" title="一个微信小程序仪表盘组件"></a>一个微信小程序仪表盘组件</h2><p>最近在一个小程序项目中做了个动态仪表盘效果，感觉有点复用价值，就顺便给组件化了，丰富了几个常用配置，绘制元素根据尺寸自适应，差不多具备了一个自定义组件的基本素质。</p><p>开发非常简单没有值得说的点，开发之外却是一步一个坑。</p><p>先来预览下效果：</p><p><img src="https://refined-x.com/asset/a/weapp-plugin-dashboard.gif" alt=""></p><p>感兴趣的直接看源码：</p><p><a href="https://github.com/tower1229/weapp-plugin-dashboard" target="_blank" rel="external">https://github.com/tower1229/weapp-plugin-dashboard</a></p><p>下面是踩坑过程。</p><h2 id="如何开发微信小程序自定义组件"><a href="#如何开发微信小程序自定义组件" class="headerlink" title="如何开发微信小程序自定义组件"></a>如何开发微信小程序自定义组件</h2><p>官方提供了一个CLI工具专门用于开发小程序自定义组件，首先全局安装这个工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @wechat-miniprogram/miniprogram-cli</span><br></pre></td></tr></table></figure><p>然后用它初始化一个自定义组件项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miniprogram init --type custom-component</span><br></pre></td></tr></table></figure><p>这一步会下载一个前端工程模板到本地，这个模板是一个基于gulp的前端自动化工程，使用前需要先安装依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure><p>有可能你会像我一样发现这个项目的默认依赖版本有点老，然后习惯性的在VSCode里用<strong>Npm Dependency</strong>自动升级了一下，重新安装，然后就傻逼了，新版babel插件会让项目跑不起来。</p><p>还原到默认版本重新安装，启动开发服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run watch</span><br></pre></td></tr></table></figure><p>这时自动化工程会将<code>src/</code>里的代码构建到<code>miniprogram_dev/</code>文件夹，这里面是一个标准的小程序目录结构，是可以用微信开发者工具导入并运行的，导入的时候注意使用测试appId。</p><p>然后这边我们编辑src里的源码文件，另一边就会同步构建到miniprogram_dev，微信开发者工具检测到文件变动也会自动重新编译项目，目前为止很美好。</p><p>但就我的亲身体验来看，这个自动化工程有点小毛病，偶尔会把个别文件给编译“丢”，比如突然样式没了，或者js编译不通过，那么js文件也就没了，微信开发者工具这边就会报错。</p><p>最坑的是，这个工程的编译过程集成了eslint代码检查，检查不通过js文件就不编译，任由开发者工具报错。默认的eslint配置是有多变态？起码对我来说这是个很难忘的经历，一下午都在咬牙切齿的查各种eslint报错是什么意思，怎么关掉。</p><p>不过eslint也有一些有意义的要求，比如<code>parseInt()</code>方法的第二个参数通常我都不传，严格来说这样确实不算好的实践。</p><h2 id="canvas在小程序组件中的使用"><a href="#canvas在小程序组件中的使用" class="headerlink" title="canvas在小程序组件中的使用"></a>canvas在小程序组件中的使用</h2><p>开发过程中遇到最坑的问题，是我自己看文档不仔细导致的，但我觉得更大的责任在于小程序官方文档太乱了。</p><p>初始化canvas实例的<code>wx.createCanvasContext()</code>方法，其实有两个参数，第二个参数通常也是都不传，仅在组件内使用时这个参数才需要传<code>this</code>，之前一直没在组件里用过canvas，导致忘了还有这么个参数，也不报错，就是canvas死活画不出东西，查了好半天才发现是这个原因。</p><p>这种情况完全可以在开发工具中给个报错，为什么不？</p><p>查文档的过程中，真心觉得小程序的文档组织太TM乱了，知识点是全的，但同一个东西的知识点散落的到处都是，比如说单独看【框架】这个栏目的内容，你根本不可能掌握小程序框架是怎么一回事，再看看“指南”才能知道个大概，然后再看组件和API，才能写出个hello world项目。</p><p>就说自定义组件的开发吧，自定义组件的接口、开发、发布、安装每个环节的内容，被分别散落在【框架】、【指南】、【工具】的不同篇幅里，也就是第一次开发自定义组件的时候，需要把整个文档都翻腾一遍，才能找到所有我需要知道的东西，你说扯不扯。</p><h2 id="发布与安装npm包"><a href="#发布与安装npm包" class="headerlink" title="发布与安装npm包"></a>发布与安装npm包</h2><p>自定义组件开发完了就要发布到npm，发布过程是全程最愉快的部分了，一点坑没有，开发环境测试没问题，运行构建命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>这时会产出一个<code>miniprogram_dist/</code>文件夹，整个项目的<code>.gitignore</code>和<code>.npmignore</code>都预置好了，如果你把代码提交到GitHub，将只提交源码和必要的工程文件；如果要发布到npm，在已经登录npm的前提下只要执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>就会按小程序支持的格式（包含<code>miniprogram_dist/</code>）将代码发布到npm，然后就可以在其他小程序项目里安装并使用了。</p><p>小程序项目安装npm包有点麻烦。</p><p>首先在小程序代码根目录（project.config.json中miniprogramRoot配置的目录）中依次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm i weapp-plugin-dashboard -S --production    // 此处以安装weapp-plugin-dashboard模块为例</span><br></pre></td></tr></table></figure><p>只有这样安装的模块才算数，一开始我随手创建了个<code>package.json</code>文件写上依赖包名称，然后执行<code>npm i</code>，虽然模块也下载了，但会在下一步的开发者工具中报错，提示找不到npm包，可能是因为<code>package.json</code>文件不规范，但是文档没有告知怎样的<code>package.json</code>才算规范。</p><p>安装完毕后，在开发者工具中看不到<code>node_modules/</code>这个目录，因为此时这些模块小程序还并不支持，需要再构建一下才能用。</p><p>首先，在开发者工具的项目配置里开启<strong>使用npm模块</strong>，然后执行“工具-构建npm”操作，成功后会产出一个<code>miniprogram_npm/</code>文件夹，这个文件夹是可以在开发者工具中看到的，到这一步npm包才算真的安装成功，可以在小程序项目中正常调用了。</p><p><img src="https://refined-x.com/asset/a/useComponent.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>再放一遍项目地址吧，注意项目里的代码是开发工程的代码，需要运行构建命令（<code>npm run build</code>）才能得到小程序组件代码。想在项目里使用组件也可以直接npm安装<code>weapp-plugin-dashboard</code>，具体步骤前面说过了。</p><p>Github：<a href="https://github.com/tower1229/weapp-plugin-dashboard" target="_blank" rel="external">https://github.com/tower1229/weapp-plugin-dashboard</a></p><p>再说点小程序开发的话题。</p><p>截至目前，小程序开发相关的讨论，热门话题基本都是围绕那些“一次开发，处处运行”的轮子，什么taro啊uni-app啊，这些东西在我看来跟“生态”不沾边，起码在目前这个大局未定的阶段，可以说除了炫技毫无意义，任何对团队负责的架构师都不应该选择这种技术栈。</p><p>我理解的生态，比如三方组件库，在小程序这几乎是市场空白；只面向企业开放的小程序插件，也没见到个正经推广的；杀手级应用也很少，大部分都是昙花一现，或者游戏类的；总体感觉就是，小程序开发没有热度，新手都在学，主力都在观望。</p><p>这可能是因为小程序还没有找到合理的变现模式，如果任何一个企业如果能率先通过小程序打通一个商业模式，那么至少能带动同行业的所有企业复制这种模式，这样开发者的开发场景就会高度集中，大家面临的问题都很相似，才有可能产生流行的三方组件，进而促成生态繁荣。</p><p>问题是，曾经的那些“变现模式”都迅速被微信封杀了，那么微信自己到底怎么定义小程序呢？小程序显然不是一个像HTML5那样的“通用媒介”，很多事情在小程序上不能做，而且这个不能做的范围，与其说是技术限制，倒不如说是人为的“政策限制”，而且这个政策非常之模糊和不确定。</p><p>涉及到流量的不行，涉及到腾讯竞品行业的不行，涉及到钱的，我觉得就算让我做我也不敢做，因为今天可以的，明天可能就不可以了，生杀大权全在微信一句话，或者连句话都没有。</p><p>就是说微信不准备让小程序成为一个公益性质的第三方平台，而是希望小程序只为微信服务，让符合微信利益的服务商以微信喜欢的方式接入，然后以小程序的形式替代对应的原生APP，从而完成对一整个“生态位”的吞噬，到那时恐怕连操作系统都要面向“微信”开发了。</p><p>照这个思路，个人开发者对微信来说，可能只是免费的外部测试团队吧。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/07/22/weapp-plugin-dashboard/#disqus_thread</comments>
    </item>
    
    <item>
      <title>监听Canvas内部元素点击事件的三种方法</title>
      <link>https://refined-x.com/2019/04/27/canvas-click/</link>
      <guid>https://refined-x.com/2019/04/27/canvas-click/</guid>
      <pubDate>Sat, 27 Apr 2019 05:56:42 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;canvas内部元素不能像DOM元素一样方便的添加交互事件监听，因为canvas内不存在“元素”这个概念，他们仅仅是canvas绘制出来的图形。这对于交互开发来说是一个必经障碍，想要监听图形的点击事件思路很简单，只要监听canvas元素本身的点击事件，再判断点击坐标位于哪一
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>canvas内部元素不能像DOM元素一样方便的添加交互事件监听，因为canvas内不存在“元素”这个概念，他们仅仅是canvas绘制出来的图形。这对于交互开发来说是一个必经障碍，想要监听图形的点击事件思路很简单，只要监听canvas元素本身的点击事件，再判断点击坐标位于哪一个图形内部，就变相实现了图形点击事件。本文将介绍三种方法，判断坐标点是否位于某个canvas图形内部。</p><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>本文介绍的三种方法适用于识别canvas内形状不规则而且位置无规律的图形点击事件，对于形状规则或者位置有规律的场景，肯定有更简便的实现，这里不做讨论。</p><h2 id="像素法"><a href="#像素法" class="headerlink" title="像素法"></a>像素法</h2><p>像素检测法的思路是，将canvas中的多个图形（如果有多个的话）分别离屏绘制，并用<code>getImageData()</code>方法分别获取到像素数据保存起来。当canvas元素监听到点击事件时，通过点击坐标可以直接推算出点击发生在canvas上的第几个像素，然后遍历前面保存的图形数据，看看这个像素的alpha值是不是0，如果是0说明落点不在当前图形内，否则就说明点到了这个图形。</p><p>根据点击坐标得到所点击的像素序号的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">像素序号 = (纵坐标-1) * canvas宽度 + 横坐标</span><br></pre></td></tr></table></figure><p>比如在宽度为 5 的画布上点击坐标<code>(3,3)</code>，根据上述公式得到像素序号是<code>(3-1) * 5 + 3 = 13</code>，如图所示：</p><p><img src="https://refined-x.com/asset/a/point-center.png" alt="坐标与像素点关系"></p><p>因为canvas导出的图形数据是将每个像素以<code>rgba</code>的顺序存成4个数字组成的数组，所以想访问指定像素的alpha值，只要读取这个数组的第<code>pIndex * 4 + 3</code>个值就可以了，如果这个值不为0，说明该像素可见，也就是点击到了该图形。</p><p>这个方法是我认为思路最直接、结果最准确、而且对图形形状没有任何要求的方法，但这个方法有一个致命的局限，当图形需要在画布上移动时，要频繁的创建数据缓存才能保证检测结果准确，受到画布尺寸和图形数量的影响，<code>getImageData()</code>方法的性能会成为严重的瓶颈。所以如果canvas图形是静态的，这个方法非常适合，否则就不适合用这个方法了。</p><h2 id="角度法"><a href="#角度法" class="headerlink" title="角度法"></a>角度法</h2><p>角度判断法的原理很容易理解，如果一个点在多边形内部，则该点与多边形所有顶点两两构成的夹角，相加应该刚好等于360°。</p><p><img src="https://refined-x.com/asset/a/checkPointIn1.png" alt="角度判断法"></p><p>计算过程可以转变为以下三个步骤：</p><ol><li>已知多边形顶点和已知坐标，将坐标与顶点两两组合成三点队列</li><li>已知三点求夹角，可以使用<a href="https://baike.baidu.com/item/%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86/957460?fromtitle=%E4%BD%99%E7%8E%84%E5%AE%9A%E7%90%86&amp;fromid=7376698&amp;fr=aladdin" target="_blank" rel="external">余玄定理</a></li><li>判断夹角之和是否360°</li></ol><p>每一步都很简单，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//计算两点距离</span><br><span class="line">const getDistence = function (p1, p2) &#123;</span><br><span class="line">  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y))</span><br><span class="line">&#125;;</span><br><span class="line">//角度法判断点在多边形内部</span><br><span class="line">const checkPointInPolyline = (point, polylinePoints) =&gt; &#123;</span><br><span class="line">    let totalA = 0;</span><br><span class="line">    const A = point;</span><br><span class="line">    for (let i = 0; i &lt; polylinePoints.length; i++) &#123;</span><br><span class="line">        let B, C;</span><br><span class="line">        if (i === polylinePoints.length - 1) &#123;</span><br><span class="line">            B = &#123;</span><br><span class="line">                x: polylinePoints[i][0],</span><br><span class="line">                y: polylinePoints[i][1]</span><br><span class="line">            &#125;;</span><br><span class="line">            C = &#123;</span><br><span class="line">                x: polylinePoints[0][0],</span><br><span class="line">                y: polylinePoints[0][1]</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            B = &#123;</span><br><span class="line">                x: polylinePoints[i][0],</span><br><span class="line">                y: polylinePoints[i][1]</span><br><span class="line">            &#125;;</span><br><span class="line">            C = &#123;</span><br><span class="line">                x: polylinePoints[i + 1][0],</span><br><span class="line">                y: polylinePoints[i + 1][1]</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        //计算角度</span><br><span class="line">        const angleA = Math.acos((Math.pow(getDistence(A, C), 2) + Math.pow(getDistence(A, B), 2) - Math.pow(getDistence(B, C), 2)) / (2 * getDistence(A, C) * getDistence(A, B)))</span><br><span class="line"></span><br><span class="line">        totalA += angleA</span><br><span class="line">    &#125;</span><br><span class="line">    //判断角度之和</span><br><span class="line">    return totalA === 2 * Math.PI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有一个局限性，就是图形必须是<strong>凸多边形</strong>。如果不是凸多边形需要先切割成凸多边形再计算，这就比较复杂了。</p><p>类似的思路还有面积法，如果一个点在多边形内部，那么该点与多边形所有顶点两两构成的三角形，面积相加应该等于多边形的面积，首先计算多边形的面积就很麻烦，所以这种方法可以直接pass掉。</p><h2 id="射线法"><a href="#射线法" class="headerlink" title="射线法"></a>射线法</h2><p>射线法是一个我讲不清道理但非常好用的方法，只要判断点与多边形一侧的交点个数为奇数，则点在多边形内部。需要注意的是，只要数任何一侧的焦点个数就可以，比如左侧。这个方法不限制多边形的类型，凸多边形、凹多边形甚至环形都可以。</p><p><img src="https://refined-x.com/asset/a/checkPointIn2.png" alt="射线判断法"></p><p>实现起来也非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const checkPointInPolyline = (point, polylinePoints) =&gt; &#123;</span><br><span class="line">    //射线法</span><br><span class="line">  let leftSide = 0;</span><br><span class="line">  const A = point;</span><br><span class="line">  for (let i = 0; i &lt; polylinePoints.length; i++) &#123;</span><br><span class="line">    let B, C;</span><br><span class="line">    if (i === polylinePoints.length - 1) &#123;</span><br><span class="line">      B = &#123;</span><br><span class="line">        x: polylinePoints[i][0],</span><br><span class="line">        y: polylinePoints[i][1]</span><br><span class="line">      &#125;;</span><br><span class="line">      C = &#123;</span><br><span class="line">        x: polylinePoints[0][0],</span><br><span class="line">        y: polylinePoints[0][1]</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      B = &#123;</span><br><span class="line">        x: polylinePoints[i][0],</span><br><span class="line">        y: polylinePoints[i][1]</span><br><span class="line">      &#125;;</span><br><span class="line">      C = &#123;</span><br><span class="line">        x: polylinePoints[i + 1][0],</span><br><span class="line">        y: polylinePoints[i + 1][1]</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断左侧相交</span><br><span class="line">    let sortByY = [B.y, C.y].sort((a,b) =&gt; a-b)</span><br><span class="line">    if (sortByY[0] &lt; A.y &amp;&amp; sortByY[1] &gt; A.y)&#123;</span><br><span class="line">      if(B.x&lt;A.x || C.x &lt; A.x)&#123;</span><br><span class="line">        leftSide++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return leftSide % 2 === 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>射线法有一种特殊情况，当点在多变形的一条边上时需要特殊处理。但在工程中我认为也可以不处理，因为如果用户刚好点在图形的边界上，那么程序认为他没有点到也讲的过去。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上三种方法都可以实现canvas中不规则图形的点击检测。其中，像素法的优势在于不挑形状，而且在静态场景中有一定的性能优势；角度法应该说只有理论价值，实用性不佳；工程中最实用的当属射线法，局限性小，实现简单，多数时候只需要知道射线法就可以了。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/04/27/canvas-click/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iBeacon蓝牙定位技术原理及实现</title>
      <link>https://refined-x.com/2019/04/01/IBeacon-Location-Technology/</link>
      <guid>https://refined-x.com/2019/04/01/IBeacon-Location-Technology/</guid>
      <pubDate>Mon, 01 Apr 2019 04:25:04 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;蓝牙定位是iBeacon技术最常被应用的方向之一，基于蓝牙定位可以实现诸如寻路、寻车、向导等很多商业需求，&lt;a href=&quot;https://tracesr.github.io/&quot; target=&quot;_blank&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>蓝牙定位是iBeacon技术最常被应用的方向之一，基于蓝牙定位可以实现诸如寻路、寻车、向导等很多商业需求，<a href="https://tracesr.github.io/" target="_blank" rel="external">觅迹导航</a>的定位系统也是基于iBeacon技术实现的。蓝牙定位又可以分为一维定位和二维定位，本文将介绍两种蓝牙定位技术的实现原理及实现方法。</p><h2 id="一维定位"><a href="#一维定位" class="headerlink" title="一维定位"></a>一维定位</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>蓝牙定位的底层技术是蓝牙测距，关于蓝牙测距在<a href="https://refined-x.com/2019/03/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FiBeacon%E6%B5%8B%E8%B7%9D%E5%8F%8A%E7%A8%B3%E5%AE%9A%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/">《微信小程序iBeacon测距及稳定程序的实现》</a>一文中已经做了详细介绍，这里不再赘述。</p><p>所谓一维定位其实就是对蓝牙测距技术的最简单应用，只要将蓝牙信标设备部署在指定点，当接收设备（手机）足够靠近信标时，就认为用户到达了指定点。之所以称之为一维定位，是因为定位结果完全依附于信标设备的位置，没有任何其他维度上的扩展。</p><p><img src="https://refined-x.com/asset/a/1wei-locate.png" alt=""></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>这种方式通常用在固定路线的沿途部署，为路线上的用户提供定位信息。</p><p>优点是部署成本和开发成本很低，缺点是只能应用在路线固定，并且定位点间隔不太密集的场景。典型的例子就是景区或者园区，景区内的路径都是经过设计的，固定而且几乎唯一；景点之间的距离也不会很近，至少在50m以上的间距。只要沿途以大致固定的间距部署信标设备，就可以为用户提供相对实时而且准确的定位信息。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一维定位的部署非常简单，如上文所述，只要确定好信标设备的有效覆盖范围，然后沿途部署就可以。部署同时收集每个或部分信标设备的位置信息，作为程序的定位检索依据。</p><p>开发方面，移动设备只要将收到的信号做距离排序，找到距离最近的一个信标设备，如果距离在指定范围内，就检索该设备的位置信息，认为用户到达了该地区。</p><p>太简单了，就不多说了。</p><h2 id="二维定位"><a href="#二维定位" class="headerlink" title="二维定位"></a>二维定位</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>二维定位顾名思义，就是可以实现二维空间中的任意定位。定位的主要理论依据<a href="https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%89%E8%BE%B9%E5%85%B3%E7%B3%BB/11034954" target="_blank" rel="external">三角形三边关系</a>公式。</p><p><img src="https://refined-x.com/asset/a/zhijiao-sanjiaoxing.jpg" alt=""></p><p>如上图，已知三角形三边长度，CD是底边AB的垂线，AD和BD的长度计算公式分别为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BD = (AB2+CB2-AC2)÷2AB</span><br><span class="line">AD = (AB2-CB2+AC2)÷2AB</span><br></pre></td></tr></table></figure><p>整体思路是，将信标设备在场地内按指定间距做网状部署，使用户在场地内任意点都可以接收到3个距离最近而且连线构成直角的定位点信息，如下图</p><p><img src="https://refined-x.com/asset/a/ibeacon-locate-method.png" alt=""></p><p>通过三角形三边关系公式，可以计算出上图中px和py的长度，也就是当前点在当前正方形网格中的坐标。</p><p>再根据当前所在正方形在整个矩阵中的位置，结合部署间距，算出当前点在整个矩阵中的坐标。</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>二维定位理论上适用于任何场景，通常用在用户活动路径不固定的自由空间中，比如展会、商场。</p><p>优点是场地适应性更强，缺点是部署成本和开发成本相对较高。以商场为例，严格按照固定间距部署蓝牙信标，往往需要结合实地情况选择合适的距离，程序也要根据实际间距做相应的计算调整。另外还要考虑不规则区域的处理，往往会将一维定位和二维定位结合使用。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>上面原理部分说起来有点啰嗦，看图其实很简单。</p><p>假设现在有一个30m * 30m的场地，将信标设备以10m为间距网状部署，共需要16个信标，每个信标都按下图所示标注上坐标信息</p><p><img src="https://refined-x.com/asset/a/ibeacon-locate-grid.png" alt=""></p><p>此时用户无论在场地内的任何位置，都将身处9个正方形网格中的一个（暂不考虑临界情况），那么移动设备收到的距离最近的4个信标点，应该就是当前所在正方形的4个顶点。</p><p>假设当前用户此时在左上角第一个正方形中，根据蓝牙测距结果，得到距离最近的3个信标点，对应的距离分别为<code>distance1, distance2, distance3</code>，如图</p><p><img src="https://refined-x.com/asset/a/ibeacon-locate-method.png" alt=""></p><p>三个顶点距离已知，部署间距已知，根据三边关系公式可以得<code>px, py</code>的值，也就是当前点在当前网格中的坐标。</p><p>在这之前先要解决一个问题，那就是三个点之间的关系。我们知道三个点肯定两两连线互为直角，但到底哪两个点在横轴上，哪两个点在纵轴上。这需要结合点的坐标信息做进一步处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//判断三点（points）的关系</span><br><span class="line">let xAxisPoints = [];</span><br><span class="line">let yAxisPoints = [];</span><br><span class="line">for (let i = 0; i &lt; points.length; i++) &#123;</span><br><span class="line">  let point = points[i];</span><br><span class="line">  //找到Y轴点</span><br><span class="line">  let xNO = point.x;</span><br><span class="line">  let yPoints = points.filter(e =&gt; e.x === xNO)</span><br><span class="line">  if (yPoints.length &gt;= 2) &#123;</span><br><span class="line">    yAxisPoints = yPoints.sort((a, b) =&gt; a.y - b.y)</span><br><span class="line">    if (xAxisPoints.length) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //找到X轴点</span><br><span class="line">  let yNO = point.y;</span><br><span class="line">  let xPoints = points.filter(e =&gt; e.y === yNO)</span><br><span class="line">  if (xPoints.length &gt;= 2) &#123;</span><br><span class="line">    xAxisPoints = xPoints.sort((a, b) =&gt; a.x - b.x)</span><br><span class="line">    if (yAxisPoints.length) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，就很容易算出定位点的横轴坐标和纵轴坐标了，再分别加上当前网格在整个矩阵中的横坐标和纵坐标，就得到了最终的定位坐标。</p><p>上例中的<code>xAxisPoints</code>和<code>yAxisPoints</code>已经对坐标信息做了排序，横轴数组第一个点的x值，以及纵轴数组第一个点的y值，就是网格在整个矩阵中的横坐标和纵坐标。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一维定位和二维定位分别有各自的应用场景，其中二维定位对实施能力提出了较高的要求。现实环境中往往还需要将一维定位和二维定位结合使用，这里需要程序设计上处理好两种情况的兼容。</p><p>得到定位信息，往往只是项目的第一步。比如在导航系统中，定位信息需要匹配最近的目标点，整个导航功能才可以开始使用。有机会后面会对导航系统的实现，做进一步的分享。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/04/01/IBeacon-Location-Technology/#disqus_thread</comments>
    </item>
    
    <item>
      <title>微信小程序iBeacon测距及稳定程序的实现</title>
      <link>https://refined-x.com/2019/03/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FiBeacon%E6%B5%8B%E8%B7%9D%E5%8F%8A%E7%A8%B3%E5%AE%9A%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://refined-x.com/2019/03/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FiBeacon%E6%B5%8B%E8%B7%9D%E5%8F%8A%E7%A8%B3%E5%AE%9A%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sat, 30 Mar 2019 09:59:24 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;iBeacon是苹果公司推出的一项低耗能蓝牙技术，由蓝牙设备发射包含指定信息的信号，再由移动设备接收信号，从而实现近场通信。微信小程序2017年开始支持iBeacon，摇一摇附近就是基于iBeacon实现的，此外iBeacon还可以实现距离测量，本文将介绍如何基于微信小程序
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>iBeacon是苹果公司推出的一项低耗能蓝牙技术，由蓝牙设备发射包含指定信息的信号，再由移动设备接收信号，从而实现近场通信。微信小程序2017年开始支持iBeacon，摇一摇附近就是基于iBeacon实现的，此外iBeacon还可以实现距离测量，本文将介绍如何基于微信小程序实现iBeacon测距。</p><h2 id="iBeacon测距原理"><a href="#iBeacon测距原理" class="headerlink" title="iBeacon测距原理"></a>iBeacon测距原理</h2><p>蓝牙信标发射的信号强度(rssi)与收发设备之间的距离，某种程度上呈正相关，因此通过合理的运算转化，可以通过rssi的值反推出与接收设备间的距离。</p><p>蓝牙信标的rssi值是一个参考值，没有固定标准。想要计算出蓝牙信标的距离，还必须知道这个信标设备的txPower值。txPower是指当距离蓝牙信标1m时的rssi值，不同的蓝牙设备或相同设备不同的工况甚至不同的场地环境，都会影响txPower值，因此这个值虽然可以测量，但一定程度上是个经验值，无法测准。</p><h3 id="rssi测距公式"><a href="#rssi测距公式" class="headerlink" title="rssi测距公式"></a>rssi测距公式</h3><p>知道rssi和txPower后就可以计算距离了，有两种计算公式：</p><p>一、 <img src="https://refined-x.com/asset/a/rssi-distance-computed-1.jpg" alt=""></p><p>这个公式里的三个变量A、B、C都是经验值，需要根据手机系统或硬件型号精确调校，通常会将所有设备的校准结果保存成一个设备信息表，移动终端先检测本机型号，然后匹配设备信息调取相应的计算配置，再进行计算。很明显这个公式是比较依赖硬件调校的，没有数据储备的前提下这个公式会很难用。</p><p>转换成js代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const calculateAccuracy = function (txPower, rssi) &#123;</span><br><span class="line">  return (0.89976) * Math.pow(rssi / txPower, 7.7095) + 0.111</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未精校情况下的测距表现：</p><p><img src="https://refined-x.com/asset/a/method1-chart.png" alt=""></p><p>先说这个图怎么看。</p><p>纵轴代表测量距离，横轴代表时间，每隔一秒取样一次，图中是近10次取样的数值曲线。<br>绿线是设备接收到的rssi值，反应硬件真实接收到的数据情况；<br>红线是套用公式计算得出的瞬时距离；<br>黄线是微信小程序自带的瞬时测距结果。</p><p>蓝牙信标与手机的实际距离1m，测试设备为红米Note7。</p><p>从上图可见，rssi值相对稳定，说明硬件没有太大问题。红线和黄线的波动都很大，说明准确度不咋地。二者的波动趋势几乎一致，所以有理由怀疑微信小程序内部也是用的这个测距公式。从结果来看，这个公式的准确度比较差，可能是因为没有精校的原因。</p><p>二、 <img src="https://refined-x.com/asset/a/rssi-distance-computed-2.jpg" alt=""></p><p>这个公式里的A就是rssi，tx是txPower，n是经验值，n的取值跟物理环境有关。</p><p>转换成js代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const calculateAccuracy = function (txPower, rssi) &#123;</span><br><span class="line">  return Math.pow(10, Math.abs(rssi - txPower) / (10 * 4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公式二的测距表现：</p><p><img src="https://refined-x.com/asset/a/method2-chart.png" alt=""></p><p>人比人得死，货比货得扔啊。</p><p>图中黄线还是波动的那么疯狂，但红线却异常稳定，而且呈现出跟绿线一致的波动幅度，说明测距精度靠谱。这个公式只有一个参数，生产环境中的调校相对简单，这里我们选择公式二作为测距公式。</p><h2 id="iBeacon测距稳定程序"><a href="#iBeacon测距稳定程序" class="headerlink" title="iBeacon测距稳定程序"></a>iBeacon测距稳定程序</h2><p>蓝牙信号本身就有波动性，加上现实环境中的很多因素也会影响到信号强度，比如物体遮挡、设备方向变化、硬件自身的稳定性等，所以接收设备检测到的rssi值通常是“跳动”的，直接使用测距公式算出的结果，往往不可用。必须实现一个稳定程序，让计算结果呈现出连续性和稳定性。</p><h3 id="数据滤波"><a href="#数据滤波" class="headerlink" title="数据滤波"></a>数据滤波</h3><p>稳定程序主要做的事就是对波段数据“削峰填谷”，也可以称作数据滤波。最简单的滤波处理，就是收集一段时间的值求平均，只要硬件不出问题，固定距离的蓝牙信标rssi值总是会在一个相对稳定的区间内变化，采样时间越长，采样的平均值就会越接近真实值，因此在静态测距场景中，求平均是最佳方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//求数组平均值</span><br><span class="line">const arrayAverage = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;</span><br><span class="line"></span><br><span class="line">return arrayAverage([...])</span><br></pre></td></tr></table></figure><p>具体实现是，当程序源源不断的接收到信标的rssi时，先用公式计算出瞬时测距结果，然后将结果存进一个数组，然后计算这个数组的平均值。静态测距时，测量结果还是非常准的，2m以内的距离误差可以低至0.1m。</p><p>实际应用中往往都是动态测距，所以采样数据的长度要加以限制，比如按后进先出的顺序，取最近10组数据。具体采样队列设为多长，要根据项目实际需求而定。采样队列的长度越长，测距结果越平滑，但对移动端的动态捕捉越迟钝；反之采样队列越短，结果越锐利，对移动端的动态捕捉越灵敏。</p><p>有时因为一些偶然因素，采样队列中会出现个别大幅偏离真实值的“燥音”数据，即使求平均也难以有效抹除影响，为消除这种影响，可以在求平均前先用<a href="http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html" target="_blank" rel="external">高斯模糊算法</a>对“偏大值”和“偏小值”做平滑处理，最大限度的降低数据噪音的干扰。</p><p>高斯模糊算法的关键是根据平均差求权重，一维高斯模糊的权重计算公式：</p><p><img src="https://refined-x.com/asset/a/gaussian-function.png" alt=""></p><p>转换成js代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//求一维队列某点的高斯模糊权重 @param(队列长度，目标位置, 平均差)</span><br><span class="line">const getOneGuassionArray = function (size, kerR, sigma) &#123;</span><br><span class="line">  if (size % 2 &gt; 0) &#123;</span><br><span class="line">    size -= 1</span><br><span class="line">  &#125;</span><br><span class="line">  if (!size) &#123;</span><br><span class="line">    return []</span><br><span class="line">  &#125;</span><br><span class="line">  if (kerR &gt; size-1)&#123;</span><br><span class="line">    return []</span><br><span class="line">  &#125;</span><br><span class="line">  let sum = 0;</span><br><span class="line">  let arr = new Array(size);</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; size; i++) &#123;</span><br><span class="line">    arr[i] = Math.exp(-((i - kerR) * (i - kerR)) / (2 * sigma * sigma));</span><br><span class="line">    sum += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return arr.map(e =&gt; e / sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于“偏大值”和“偏小值”的概念将在下文介绍，这里只要知道我们的模糊目标是那些“极端数据”就行了。</p><h3 id="时间加权"><a href="#时间加权" class="headerlink" title="时间加权"></a>时间加权</h3><p>基于采样队列求平均的处理方式，不可避免的会让结果产生滞后性，这时可以引入时间加权的补偿算法。</p><p>所谓时间加权，是指在求平均值的时候，给距离当前时间较近的值更高的计算权重，反之给距离当前时间较远的值较低的计算权重，实现起来也非常简单。</p><p>以最简单的权重分配为例，将采样队列一分为二，按时间远近定位为“当前组”和“过去组”，比如说我想让当前组的权重是过去组的2倍，那么只要将当前组数据全部复制一份加入队列，然后再计算新队列的平均值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//时间加权处理</span><br><span class="line">queue = queue.slice(0, parseInt(queue.length / 2)).concat(queue)</span><br><span class="line">//求平均</span><br><span class="line">return arrayAverage(queue)</span><br></pre></td></tr></table></figure><h3 id="动态跟进"><a href="#动态跟进" class="headerlink" title="动态跟进"></a>动态跟进</h3><p>经过时间加权处理后，数据的滞后性会得到一定的抑制，但如果遇到比较“陡峭”的距离变化，这种处理仍然会给出一个相对“平滑”的反馈，为了让稳定程序能更好的感知动态变化，并且做出跟进反应，还需要人为的设置一些特殊条件。</p><p>首先，如何判断移动设备正在远离或靠近？</p><p>这里有一个简单的思路，可以先找出采样队列中的最大值和最小值，然后以一定的阈值找出偏大值和偏小值。比如队列中的最大值是3，最小值是1，阈值设置为0.1m，那么大于2.9m的数据都算偏大值，小于1.1m的数据都算偏小值。偏大值和偏小值的队列长度最长不超过总队列的二分之一。</p><p>然后，如果偏大值集中在队列的前三分之一部分，那么我们可以认为移动设备正在果断远离；反之偏小值集中在队列的前三分之一部分，则可以认为移动设备正在靠近。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//maxCount为偏大值的序号数组</span><br><span class="line">//minCount为偏小值的序号数组</span><br><span class="line">//queueLength为队列长度</span><br><span class="line"></span><br><span class="line">if (arrayAverage(maxCount) &lt; parseInt(queueLength / 3)) &#123;</span><br><span class="line">    console.log(`正在远离`)</span><br><span class="line">&#125; else if (arrayAverage(minCount) &lt; parseInt(queueLength / 3)) &#123;</span><br><span class="line">    console.log(`正在靠近`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于这种远离和靠近的趋势判断，我们可以人为的让数据向运动方向做更激进的倾斜。怎么做呢？跳过时间加权逻辑，如果判断为正在远离，那么就将队列中的偏小值过滤掉，反之则将偏大值过滤掉，只计算剩下的数据；这种处理会得到一个明显过激的结果，但考虑到现实世界中的运动往往具有惯性，这种激进处理，可能会更贴合真实的运动情况，而且让数据的响应更“灵敏”。</p><h3 id="效果检验"><a href="#效果检验" class="headerlink" title="效果检验"></a>效果检验</h3><p>做到目前为止效果怎么样呢，直接看图吧。</p><p>下图中，绿线依然是rssi值，红线是根据rssi直接算出来的瞬时测距结果，黄线是加入稳定程序后的测距结果。</p><p>第一张图是相对静止的条件，可以看到黄线相对红线明显更加平稳，说明稳定程序还是起作用的。</p><p><img src="https://refined-x.com/asset/a/stabilization-1.png" alt=""></p><p>第二张图是模拟快速远离的场景，可以看到黄线在保证平稳的前提下紧跟红线，没有被甩掉，主要体现的是稳定程序的动态跟进效果。</p><p><img src="https://refined-x.com/asset/a/stabilization-2.png" alt=""></p><p>第三张图是抡胳膊甩手机+遮挡信号模拟出的场景，貌似稳定程序也架不住了，有点飘忽。</p><p><img src="https://refined-x.com/asset/a/stabilization-3.png" alt=""></p><p>以上是关于稳定程序的简要实现思路，生产环境中肯定会面临更加复杂的情况，免不了还要做大量调试，这里只是抛砖引玉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>蓝牙测距简单来说就是一个公式的应用，本身比较简单，基于测距可以实现很多近场应用，比如近场签到、近场推送等等，更进一步甚至可以实现对移动设备的定位，有了定位信息，很多室内定位、室内导航相关的应用就都可以实现了，下一篇会详细讲解如何基于iBeacon技术实现定位。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/03/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FiBeacon%E6%B5%8B%E8%B7%9D%E5%8F%8A%E7%A8%B3%E5%AE%9A%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>给前端自学者的建议</title>
      <link>https://refined-x.com/2019/02/27/%E7%BB%99%E5%89%8D%E7%AB%AF%E8%87%AA%E5%AD%A6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/</link>
      <guid>https://refined-x.com/2019/02/27/%E7%BB%99%E5%89%8D%E7%AB%AF%E8%87%AA%E5%AD%A6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/</guid>
      <pubDate>Wed, 27 Feb 2019 05:05:13 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;blockquote&gt;
&lt;p&gt;自学可能是前端圈最主流的入行方式，因为较低的准入门槛，造就了近几年的前端热。越来越多的人想自学前端，但前端技术经过爆炸性的发展，如今早已不是当年那个HTML+CSS+Javascript打天下的时代了，这对自学者来说会造成很多困扰，不知从何学起。我
          
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>自学可能是前端圈最主流的入行方式，因为较低的准入门槛，造就了近几年的前端热。越来越多的人想自学前端，但前端技术经过爆炸性的发展，如今早已不是当年那个HTML+CSS+Javascript打天下的时代了，这对自学者来说会造成很多困扰，不知从何学起。我自学前端6年了，本文整理了可能对新人有帮助的一些建议，希望大家在<strong>前端路上</strong>能少走弯路，也算暗合了本博客的主题了^ ^。</p></blockquote><h2 id="学习前端，基础先行"><a href="#学习前端，基础先行" class="headerlink" title="学习前端，基础先行"></a>学习前端，基础先行</h2><p>自学前端一定要从基础开始学，按照html5规范，系统学习html+css+JavaScript。</p><p>其中html+css属于视图开发技术，天生就是要一起学，一般两周左右可以学完；JavaScript属于逻辑层，这是一门独立的语言，自成体系。不过具体到Web前端开发中，JavaScript又可以与视图层配合，响应交互操作，实现交互效果，完成业务开发，如果你有良好的语言基础，学JavaScript也会非常快。学JavaScript开发网页，可以一并学习jQuery，不要听别人说jQuery过时就没兴趣，jQuery是对JavaScript非常良性的封装，虽然过时但至少无害，而且其中的封装思想对日后的提升大有裨益。</p><p>打基础期间要耐得住寂寞，你学的这些东西相对当下的热门名词而言，会显得非常基础老旧，ES6、Typescript、Nodejs、WebPack、Vue、React、MVVM、单向数据流/双向绑定、WPA、等等等等，都不要急于学习，他们都是基础之上开出来的花，基础好了，理解这些东西顺理成章，基础不牢，专门摘花摘果，也是空中楼阁不能持久，尤其不要过早接触高级框架，这是有害的。</p><h2 id="自学的重点是理清技术脉络"><a href="#自学的重点是理清技术脉络" class="headerlink" title="自学的重点是理清技术脉络"></a>自学的重点是理清技术脉络</h2><p>自学过程中，除了学技术本身，更重要的是理清技术脉络，用技术脉络将技术串联起来，形成系统。</p><p>只有技术成了体系，才能发挥出技术真正的能力，这也是为什么我认为过早接触高级框架是有害的，因为不利于形成健全的技术体系，一旦框架本身出了问题没有解决思路，更可怕的是，即使向别人求助，都不能准确定位问题，因为问题所发生的地方，很可能不在你的技术脉络中，这就非常可悲了。</p><p>基础打好以后，应该有能力模仿开发大部分日常见到的网页和效果，这时再去关注前面提到的那些技术名词，去思考他们与核心技术的关系，他们的应用场景是什么，比我现在的开发手段有什么优势，同样解决这个问题的还有哪些技术，他们横向上相比有什么异同。前端技术在几年的时间里爆炸性发展，但理清脉络后就会发现，前端开发技术核心的改动非常小，新技术无非是在开发效率、维护性、性能方面的探索。</p><p>这些东西都是好的，但不是必须的，要有选择的学习。当你不知道学一个东西具体有多大用处时，那就不要学，只要搞明白它“是什么”和“为什么”就可以，毕竟时间不是无限的，但技术的深度却近乎无限，即使相对简单的html+css，很多人做了好几年都未必真的学会了。</p><h2 id="视野才是最高的技术壁垒"><a href="#视野才是最高的技术壁垒" class="headerlink" title="视野才是最高的技术壁垒"></a>视野才是最高的技术壁垒</h2><p>学前端但不要止步于前端，要探索所有的关联技术。前端开发体系只是Web开发体系的一部分，而Web开发体系又只是软件开发体系的一部分，最终，开发不过是业务的一环，而业务本身又只是商业的一环。认清自己所处的位置，尽一切可能扩大视野，有一天你会发现，视野才是最高的技术壁垒。</p><h2 id="积累自己的优质证明"><a href="#积累自己的优质证明" class="headerlink" title="积累自己的优质证明"></a>积累自己的优质证明</h2><p>工作中最核心的竞争力就是基础知识和学习能力，这两种东西等于无限大的潜力。但具体到面试中，公司更希望你能直接接手现有业务，所以对口的技术栈和一定的工作经验是首要条件。技术栈可以自己补齐，工作经验如果没有，那至少要提供足够的“证据”，证明你值得让公司为你试错。比如博客可以作为学习轨迹的证据，项目可以作为动手能力的证据，算法是基础扎实的证据，操作系统知识是视野宽阔的证据，对我个人而言，如果你能讲出一个相对完整的前端知识脉络，就是很大的加分项。注意积累和总结，等着量变引发质变的那一天。</p><h2 id="关于个人项目"><a href="#关于个人项目" class="headerlink" title="关于个人项目"></a>关于个人项目</h2><p>优秀的个人项目毫无疑问是求职者最佳的名片，但对新人来说，没有经验没有技术，很可能把项目和DEMO搞混了。</p><p>项目的目的一定是证明自己，而不是串联尽量多的知识点，把一个新颖又贴合实际的想法变成现实，比运用十八般武艺做出个无聊的东西要好的多。只要技术栈符合公司要求，剩下的我会更看重这个项目有哪些新颖的想法，有哪些另辟蹊径的手段，如果能有真实用户在使用，那就更好了。</p><p>实际上，当你真的动手去做一个自己有兴趣的东西时，自然会不满足于对已知技术的简单应用，不由自主的就会去深挖瑕疵背后的原因，去查找更好的解决方法，而这正是日后工作中最能拉开你与同事间差距的能力——解决未知的问题。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文源自对一位读者的回信，整理截取了其中有分享价值的部分，分享给大家。但人是经历的产物，我的观点只是我的观点，不一定适合每个人，如果有不同看法，欢迎评论交流。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/02/27/%E7%BB%99%E5%89%8D%E7%AB%AF%E8%87%AA%E5%AD%A6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>时隔两年，再次上手小程序开发</title>
      <link>https://refined-x.com/2019/02/25/%E6%97%B6%E9%9A%94%E4%B8%A4%E5%B9%B4%EF%BC%8C%E5%86%8D%E6%AC%A1%E4%B8%8A%E6%89%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</link>
      <guid>https://refined-x.com/2019/02/25/%E6%97%B6%E9%9A%94%E4%B8%A4%E5%B9%B4%EF%BC%8C%E5%86%8D%E6%AC%A1%E4%B8%8A%E6%89%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</guid>
      <pubDate>Mon, 25 Feb 2019 08:06:43 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;blockquote&gt;
&lt;p&gt;小程序开发框架经过两年左右的迭代，发展的越来越成熟和完善了，无论框架层面还是开发工具层面，体验都上升了一个层次，借《宝贝成长助理》这个项目的契机，总结一下在2019年这个时间点，小程序开发的现状。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2
          
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>小程序开发框架经过两年左右的迭代，发展的越来越成熟和完善了，无论框架层面还是开发工具层面，体验都上升了一个层次，借《宝贝成长助理》这个项目的契机，总结一下在2019年这个时间点，小程序开发的现状。</p></blockquote><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>做宝爸快一年了，自然会花一些精力调整知识结构，关注婴幼儿成长方面的知识，现在的宝宝在营养方面普遍处于过剩状态，身边越来越常见到那种明显“富态”的宝宝，对于孩子何谓胖何谓瘦众说纷纭，为了有一个权威可靠的标准去衡量孩子的生长健康状况，我查了世界卫生组织提供的<a href="https://www.who.int/childgrowth/standards/en/" target="_blank" rel="external">婴幼儿成长标准</a>，标准以天为单位，提供5岁以内婴幼儿的身高、体重、BMI（衡量胖瘦）等指标的分布占比信息，也就是说任意天数的宝宝都能查到当下最符合健康成长规律的身高、体重、BMI数值，也可以查到宝宝当前的成长数据处于整体样本库中的什么位置，以此衡量宝宝的成长状态，辅助纠正宝宝的喂养问题。</p><p>经过一个周的开发，目前初代版本已上线，欢迎扫码体验。</p><p><img src="http://refined-x.com/asset/baby_assistant.png" alt="成长助理"></p><h2 id="整体感受"><a href="#整体感受" class="headerlink" title="整体感受"></a>整体感受</h2><p>两年前小程序刚推出的时候也是我第一次接触小程序开发，当时漫无目的的做了一个DEMO项目，并写了一篇<a href="https://refined-x.com/2017/07/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/">《小程序上手指南》</a>，内容非常粗浅，本以为时隔两年重读小程序开发文档，会有很多“硬货”，然后并没有。相比两年前小程序框架最大的改动就是引入了组件和插件两个概念，极大提升了小程序的开发体验，但其实在熟悉现代前端框架的开发者眼里，这些都是早已经过时间检验的最佳实践，没有是小程序的缺陷，有了才是顺理成章，所以这方面不能算惊喜。</p><p>另外，<a href="https://developers.weixin.qq.com/wxaplugin?action=index&amp;start=0&amp;rows=20&amp;lang=zh_CN" target="_blank" rel="external">小程序插件库</a>的入口藏得有点深，竟然不在文档的一级导航上，也没有整合到开发工具中，有点奇怪。</p><p>真正令我印象深刻的点有五个。</p><ol><li>开发工具的真机预览和调试功能特别好用，可以说完全符合预期，因为我之前没有关注这个功能的迭代过程，所以对我来说冲击很大，有种从0到100一步到位的惊艳感。</li><li>文档新增的<a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a" target="_blank" rel="external">《小程序开发指南》</a>非常值得一读，能帮助加深对小程序整体技术架构的理解，减少一些跳坑几率。</li><li>还不错的动画API。动画API其实是操作CSS动画的语法糖，目的是让CSS动画变得可编程，是很好的功能，使用体验一般吧，不好也不坏。</li><li>符合开发者利益，符合用户利益。小程序框架的一些改动非常有心，比如新增的几个开放能力组件，开发者可以在用户不授权不登陆的情况下展示用户基本信息，很多本不需要用户系统，仅仅想展示一下用户头像的业务，终于有了正确的实现方式；而对用户来说，基本信息并没有被开发者获取到，减少了无意义的授权，双赢。</li><li>无后端开发的典范——小程序云开发。小程序对开发者的定义从来不只是程序员群体，而是包括产品经理、设计师、甚至中学生在内的所有需要开发小程序的人，所以小程序开发框架越迭代越简单，而有了云开发之后，可以说真正做到了<strong>任何人都可以通过简单学习去开发一个功能完善的小程序</strong>。这一点下面单独展开说。</li></ol><h2 id="小程序云开发"><a href="#小程序云开发" class="headerlink" title="小程序云开发"></a>小程序云开发</h2><p>小程序云开发是微信官方推出的无后端开发服务。无后端开发模式不是新鲜事物，甚至经过三五年的发展这个词已经有些过气了，并不为人所知，但无后端的思想和一些典型经验在小程序云开发中体现的淋漓尽致，细节处又与业务结合的恰到好处，相比我之前了解的其他无后端服务，小程序云开发给我的感受就好像：一个从没摸过钢琴的人，一上手竟弹出肖邦的水平。</p><p>无后端其实可以简单粗暴的归纳为数据库、存储空间、算力（云函数）以及其他们的运营托管服务的打包租赁，单纯拿出来说是特别简单的一个东西，而这几样东西被小程序开发工具有机的整合起来，却呈现出一种新的生命力。</p><p>云开发提供的是非关系型数据库，但文档里从头到尾你看不到非关系型这几个字，只有寥寥几个简单的示例，一下就能明白这个东西该怎么用，剩下的很多文档甚至都不用看了，等到用的时候再来查就行，简单业务在小程序端就能实现数据库的增删改查；存储空间不说了，本来就简单，整合到云开发的API里之后也是一如既往的简明易懂；云函数是近一两年出的新东西，BAT三家云服务都在做，很长一段时间我不理解云函数和我50块/年的<a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=y31qmczl" target="_blank" rel="external">阿里云虚拟机</a>比有什么优势，但就这样一个东西被小程序整合了用户鉴权之后，简直成了神器，复制黏贴文档上的示例代码，简单几步就能实现用户登录；结合数据库和存储服务，只要不是太复杂的业务都能靠云函数搞定。云函数用的还是Nodejs语言，实在想不出小程序开发哪里还能用得到后端，所以我说，小程序的云开发是无后端开发的典范，是对无后端技术整合的最佳实践。</p><p>这也暗合张小龙在最近一次年度演讲中提到的他对技术的看法，大意是技术的价值不在于技术本身，而在于正确的应用场景。实际上微信7.0的视频动态功能里，视频配乐就应用了AI技术去匹配背景音乐，如果你还没用过这个功能，建议你马上体验一下。我个人的感受是做的特别好，甚至比很多将AI作噱头的营销PPT吹的都要好。推送的前几首音乐往往是AI匹配的，因为我经常拍的就是我儿子，我发现推送的音乐首先可以做到在情感类型上与视频内容匹配，是可爱的还是动感的还是搞笑的，都判断的很准确，这一点非常重要，可以强化视频的情感表达，让本来没有那么好玩的一个视频变得妙趣横生；然后音乐的节奏也能做到跟人物动作匹配，甚至有时候节奏还能对上人物的口型，最终的效果就是，经常让我觉得背景音乐成了视频动态的点睛之笔，这种感受恐怕只有亲身体验过人才会知道有多棒。将AI技术应用的这么好，微信团队却从没有公开提过，甚至没看过张小龙那次演讲的人，可能一辈子都不会知道微信里的这个小功能，其实运用了当下最尖端的AI技术，并且炉火纯青。</p><h2 id="一些遗憾"><a href="#一些遗憾" class="headerlink" title="一些遗憾"></a>一些遗憾</h2><p>夸了这么多但总归还是有一些遗憾，主要有四点。</p><ol><li>canvas应用受限。我这次做的项目里涉及到数据呈现，本来希望能用canvas绘制，但canvas是原生组件，脱离webview独立渲染，导致跟swiper组件结合使用时出现异常，表现为页签滑动但是页签里的canvas不动。最后的解决方法是先用canvas绘制出来，然后截屏保存再处理成背景图片，没办法，谁让我的PS水平画不出来我想要的效果呢。</li><li>官方社区还是不理想。貌似活跃了可以忽略不计的那么一点点吧，但总体来说问答数量的积累还是不够，经常有问题搜不出来，而开发中的问题如果你等着官方给你回复，估计等半天等来的答案会让你更上火，还不如百度一下来的效率。社区的搜索功能还有一个明显的槽点，搜索输入框后面的放大镜是不能点击的，只能通过回车键进入搜索结果，很难想象这个社区是微信团队做出来的。</li><li>开发文档仍然有一些地方不够细致，比如canvas的一些接口和文件操作的一些接口，怎么说呢，会让你有一种不懂的时候怎么看都不懂，懂了之后再看“奥原来是这个意思啊”的感觉。</li><li>开发工具表现的不太稳定，开发过程中发现canvas绘制和文件操作方面有时候跟真机表现不一致，然后不知道什么时候再看就莫名其妙的正常了，很奇妙；然后就是老生常谈的问题，编辑器不好用，而且有低级错误，在小屏笔记本上选中一段代码点鼠标右键，代码的选中状态会消失而且代码会网上滚动一行左右。</li></ol><h2 id="关于跨平台开发框架"><a href="#关于跨平台开发框架" class="headerlink" title="关于跨平台开发框架"></a>关于跨平台开发框架</h2><p>我关注到最近圈子里出现了一种跨平台开发框架，可以一统包括小程序在内的各种前端开发平台，妥妥的前端版“一次开发，处处运行”。优点显而易见，如果需求上同时需要一个小程序和一个H5，业务完全一样，那么代码就可以100%复用，完美。</p><p>但我对这种技术架构不感冒，我倾向于用最直接的方式去开发目标平台，首先小程序自身框架做到目前的程度，是可用的，吐槽开发体验我觉得就是鸡蛋里挑骨头了。即便考虑到代码复用，我也不认为一套代码同时跑在小程序和H5上是一种好的技术架构，因为我的经验是，每个平台都有自己的业务特点，会催生出不同的业务需求，随着时间的推移，他们终究会成为不同的东西，到那个时候想要摆脱这套框架，带来的成本恐怕就是重构级的。</p><p>而且这种包装本身就会带来很多问题，需要跟进平台更新，需要持续抹平平台差异，你代码复用省下的时间要能覆盖掉这些维护成本才行，可能是我没遇到合适的场景吧，我只能想到做外包的时候用一下比较省事，反正后续不需要自己维护，其他情况真的想不到了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>受限于这次的小程序项目比较简单，这次的体验还不够全面和深入，暂且总结以上几点，总体来说小程序已经做的特别好了，开发体验不错，其他细节以后有机会再深入体验吧。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/02/25/%E6%97%B6%E9%9A%94%E4%B8%A4%E5%B9%B4%EF%BC%8C%E5%86%8D%E6%AC%A1%E4%B8%8A%E6%89%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2018年度总结，一个技术人的而立之年</title>
      <link>https://refined-x.com/2019/01/22/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%9A%84%E8%80%8C%E7%AB%8B%E4%B9%8B%E5%B9%B4/</link>
      <guid>https://refined-x.com/2019/01/22/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%9A%84%E8%80%8C%E7%AB%8B%E4%B9%8B%E5%B9%B4/</guid>
      <pubDate>Tue, 22 Jan 2019 05:29:44 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;作为一个技术人，我一直信奉稻盛和夫的“工作即修行”，过去将多数精力都投入在工作中。2018年我刚好30岁，到了这个年纪人的角色往往会发生一些转变，来自生活的负担更多也更重了，所以过去的一年我做了一些调整，也做了一些尝试，收获不多，总结起来可以用跌跌撞撞来形容，只能说，但行好
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>作为一个技术人，我一直信奉稻盛和夫的“工作即修行”，过去将多数精力都投入在工作中。2018年我刚好30岁，到了这个年纪人的角色往往会发生一些转变，来自生活的负担更多也更重了，所以过去的一年我做了一些调整，也做了一些尝试，收获不多，总结起来可以用跌跌撞撞来形容，只能说，但行好事吧。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="结束创业"><a href="#结束创业" class="headerlink" title="结束创业"></a>结束创业</h3><p>两年前加盟一个创业团队，负责UI/UE/前端，去年6月退出了。这是段很有意思的经历，让我见识了很多新的思路，新的做事方式，最重要的是，我见到了现实环境中想做成一件事会面临什么样的困难。创业失败这事真是没什么值得说的，可能因为提前准备的比较充分吧，连我自己也没当回事，当时信心百倍的时候，我就在心里设好了deadline，两年时间，两年之后重新评估。适逢两年，经历了项目从信心满满到希望渺茫，再加上年初宝宝出生，我需要一个更稳定的工作环境，所以18年6月我果断退出了。</p><h3 id="新工作"><a href="#新工作" class="headerlink" title="新工作"></a>新工作</h3><p>新公司做互联网教育的某垂直领域，上班时间相对自由，离家5分钟车程，业务相对稳定。但习惯了紧凑的节奏一时半会我也闲不下来，再加上长期看公司仍然充满不确定性，业务会变，市场会变，行业会变，仍然需要保持敏锐。说到底，一个公司人的核心竞争力始终是为公司盈利的能力，能够结合外部环境客观评价自己的价值，是公司人的基本功，从这一点上来说，每个人都应该保有危机感。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>生活方面，手忙脚乱的做了快一年的爸爸，前所未有的忙和累，生活琐事暴增，大多是跟孩子相关的，作为一个技术男，打理生活琐事恐怕比承受身体上的累更辛苦；而且这一年我也突然感受到了身体的极限，不管多累睡一觉第二天就满血复活的日子怕是一去不复返了。对儿子的教育一开始也是心里非常没底，买书买课各种充电，这段时间过来，现在我不那么紧张了，因为教育问题在“道”的层面是些人尽皆知的道理，没有太多指导意义，而在“术”的层面就太庞大了，而且大多数都直指父母自身的意识形态，说白了就是父母自己做的好，孩子自然就好，自己做不到的事，也不要妄图教会孩子，所以心态首先放平，教育孩子先教育自己。</p><p>说到这我想推荐一个今年最让我印象深刻的课程，虽然是给父母看的沟通课，但所讲的内容我觉得任何人都应该看一看，讲的特别简短易懂，不会浪费很多时间，我已经两刷了，有时间还想再听一遍。</p><p>《亲子沟通课》 <img src="https://refined-x.com/asset/%E4%BA%B2%E5%AD%90%E6%B2%9F%E9%80%9A%E8%AF%BE.png" alt="沟通课"></p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>这一年我也尝试做了一些输出，除了原创博客之外，还包括开源项目、做前端周刊、做培训课程、做公众号等等。</p><h4 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h4><p>在Github上开源了十来个项目吧，灵感大都来自工作中遇到的问题或者觉得有兴趣的技术点，多数都是轮子级别但含金量有限，关注度最高的<a href="http://refined-x.com/Vue-Access-Control/"><strong>Vue-Access-Control</strong></a>是一个基于Vue的前端权限控制框架，也仅仅700多个star。</p><p>但这方面我自己挺知足的，对我来说做开源项目也是一个学习提升的过程，首先我要自我审视这个项目有没有开源价值，功能是否完善；发布后又要接受其他开发者的检验和质疑，换一个应用场景可能会遇到当初我没想到的问题，这些都是平时工作中很难得的技术素材。</p><h4 id="前端周刊"><a href="#前端周刊" class="headerlink" title="前端周刊"></a>前端周刊</h4><p>另外今年初我上线了一个前端周刊项目<a href="https://frontend-weekly.com/" target="_blank" rel="external">《frontend-weekly》</a>，如周刊介绍所说，我觉得每个人的关注点都是片面的、受局限的，frontend-weekly希望汇集更多视角，创造一个更全面的前端学习资料库，并以此让每位参与者受益。</p><p>其实做这件事最初的动机是，当时我见到的各种周刊、邮件列表、资源列表等等都不能满足我的需求，我的需求其实也就两点，</p><ol><li>排除入门级内容，因为这些资源太多了，随处可查；</li><li>广泛涉猎，不要单独局限于某几个行业大牛的博客，也不要局限于纯前端的东西，如果说哪个领域是最能发挥举一反三力量的，那一定是开发领域，多看点多学点没坏处。</li></ol><p>所以我就自己做了一个前端周刊，希望服务于小范围的前端同行，也顺便督促自己坚持每周学习。这一年下来说实话运营的不好，内容源大部分都来自我自己平时的阅读积累，再就是群里的伙伴推荐，距离当出的“汇集视角”的目标差了一大截。</p><p>这件事坚持做了一年，我完全没有感觉到负担和压力，因为每天阅读本来就是一个技术人应该保持的习惯，我只是将看到有价值的内容记录一下，每周定时发布而已，如果有感兴趣的同行也非常欢迎能加入进来，一起将这个项目做的更好。周刊介绍里有项目的Github地址，也可以加入QQ交流群：<strong>361917044</strong>。</p><h4 id="知识付费"><a href="#知识付费" class="headerlink" title="知识付费"></a>知识付费</h4><p>知识付费是一个很有诱惑力的方向，理论上每个人都能为自己的技能明码标价，但其实跟所有的内容行业一样符合二八原则，绝大多数的收入都集中在两成左右的头部作者手里，小白如果不是精通运营，大部分都是陪跑的。去年我自己也出了一套课程和一个Chat，收入惨淡，在这顺便汇报一下吧，让大神们见笑了，算是给准备上车的同行一个底线参考。</p><p><a href="https://gitbook.cn/gitchat/column/5b679a1d201ffa4ab88e7d5d" target="_blank" rel="external">《Hybrid App 开发快速指南》</a>。这套14节的课程从内容准备到课程编写，前后投入大半年的时间吧，目前为止收入3k左右记不太清楚了，虽说课程可以产生持续收入，但这东西最大的销路还是朋友圈，我朋友圈里没有大牛背书，过了平台推广红利期之后就很少有人问津了，当然主要还是水平有限。</p><p><a href="https://gitbook.cn/gitchat/activity/5a1f620f52525e427b667ca6" target="_blank" rel="external">《基于Vue实现前端权限控制》</a>。这场Chat到目前为止陆陆续续的收入有1k多，在这我想说说Chat这种形式，作者针对一个问题研究透，认真准备个三五天出一篇博文，约定时间与消费者加群互动；消费者提前阅读文章并提问，Chat当天大家加一个微信群由作者集中回答问题，形式简单直接有效率。对消费者来说如果想学会一个知识点并且能够应用到实践中，从金钱成本和时间成本上说Chat都是目前能找到的最优解。</p><p>在做上面这些事情的过程中发现，由于读者的层次各不相同，知识想要有效传递还是少不了一对一这种最基本的沟通方式，所以又开通了知识星球作为付费咨询服务的入口，星球里一遇到提问的，基本上就加微信聊了。知识星球这种形式本身不会带来流量，完全是个人品牌塑造之后自然而然形成的一种收费入口，所以我的星球收入就更少了，极偶尔能来个朋友问下问题，我都高兴的跟过年似的，这个东西大家量力而行吧。</p><p><img src="https://refined-x.com/asset/code-xiaomiquan.png" alt="知识星球"></p><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><p>最后我的原创前端博客<a href="https://refined-x.com/"><strong>前端路上</strong></a>仍然坚持更新，虽然过去的一年才更新了8篇文章，但写博客这事我一定会坚持下去，而且我也推荐所有人都去尝试，尤其对于技术人来说，写博客的好处太多了。写博客首先是一种强制学习，你知道一个知识点和能写明白一个知识点，两者的差距比想象中要大的多，而这个差距在写的过程中可以学习和补齐；另外写作也是一种表达，表达就会遇到别人的赞同或不赞同，无论哪种情况我都有收获，要么收获信心要么收获思路。</p><p>另外可能有的朋友没有搭建博客的经验，感觉维护一个博客很麻烦，这里再分享一下我自己博客的技术栈吧，一个非常省心而且几乎不花钱的博客配置。</p><ul><li>博客程序：Hexo，本地编写Markdown格式，构建html发布</li><li>服务：GitHub Page，免费不限空间的静态文件托管服务</li><li>CDN：七牛云个人免费版+免费https证书，GitHub Page国内访问非常不稳定，CDN加速是必要补充</li></ul><h2 id="进行中"><a href="#进行中" class="headerlink" title="进行中"></a>进行中</h2><p>以上就是过去一年我的主要回顾吧，另外还有几件事是最近开始做的，还没摸到门道这里就简单介绍一下吧，班门弄斧了。</p><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><p>理财是一个人一生中无可回避的问题，而且想要把这件事做好可比把代码写好难多了。理论知识得慢慢补，实践上基金、定投、短期、长期都在陆续少量的尝试，实践出真知，慢慢来吧。</p><p>说到投资免不了要提P2P，过去的一两年P2P算得上平民最佳投资方式了，动不动就年收益10%以上，但踩雷事件频发后收益率也基本都跌下来了，往后怎么发展还说不准，个人感觉现在已经不太合适上车了。</p><p>股票因为之前家里有一笔失败的股票投资所以我对股票完全提不起兴趣，感觉风险和收益根本就不成正比，或者说应该说入门门槛太高，不适合贸然尝试。</p><p>投资意味着风险，风险规避也是理财不可或缺的内容，对保险知识的学习就说来话长了，以后会单独另起一篇专门普及保险知识的文章，已经在写了，近期就会发布在博客上。</p><h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3><blockquote><p>再小的个体，也有自己的品牌</p></blockquote><p>这句slogan可能是很多人做自己公众号的动力，也是指导个人订阅号差异化运营的很好总结，但一直以来我都打心眼里觉得我不需要做公众号，我没有那么多一定要借助公众号输出的东西。</p><p>后来我陆续接触到很多新东西，学到新知识，在自己偷偷欣喜之余，也想把自己成长的点滴记录分享出来，想必在不同的时间之上地点之外，可能正好有一个曾经的我，正好需要这些经验，公众号是一个合适的载体，所以我决定试着做一个公众号，梳理我觉有价值的东西。就我个人而言这也是一件特别有意义的事，技术博客可以记录技术的成长，公众号则记录了我整个人的成长，所以这件事我也会长期做下去，无论世俗意义上做的好与不好。</p><p>公众号的内容框架大致搭建好了，现在还在内容填充阶段，我写东西比较慢，暂时没有多少我自己满意的内容，但是也欢迎大家的指正和批评。</p><p><img src="https://refined-x.com/asset/wechat.jpg" alt="公众号"></p><h3 id="觅迹寻路"><a href="#觅迹寻路" class="headerlink" title="觅迹寻路"></a>觅迹寻路</h3><p><a href="https://tracesr.github.io/" target="_blank" rel="external"><strong>觅迹寻路</strong></a>是我的个人项目，源自一个偶然的灵感，纯前端实现了一个简易的路径规划，后来琢磨着这东西还是有一定应用场景的，就利用周末时间把导航系统和地图编辑器都给做出来了，最近又照葫芦画瓢整了一个官网，下一步会寻求一些项目上的合作。</p><p>简单说下这个项目吧，核心是一个不带定位功能的路径规划，输入起点终点告诉你怎么走，起点需要用户自己寻找身边参照物，受此局限，典型的应用场景应该是大型商超，商超对营销需求比较大，这套系统也很容易融入促销信息和商家展位之类的营销元素，理论上大型会场、展厅、园区也都可以使用。</p><p>现在核心功能都开发完成了，初期所有开发定制服务全免费，有合作意向的朋友可以直接联系我。</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>2018无论好与不好都过去了，回顾是为了更好的展望，2019我对自己定下三个目标：</p><ol><li>丰富技术栈，TS、Flutter、Nodejs都要有上线项目</li><li>上线一个小程序，没什么特别的原因，就是执念</li><li>坚持更新公众号，目前规划中的内容已经有8篇了，起码都写完吧</li></ol><p>新年Flag立了又立，如今很多人都不愿再立了，最后送大家一句话共勉吧。</p><blockquote><p>时间只会让你老去，其他什么都不会带来；只有你想改变，你才能改变。</p></blockquote>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/01/22/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%9A%84%E8%80%8C%E7%AB%8B%E4%B9%8B%E5%B9%B4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>前端检测修复IOS拍照旋转问题</title>
      <link>https://refined-x.com/2019/01/09/%E5%89%8D%E7%AB%AF%E6%A3%80%E6%B5%8B%E4%BF%AE%E5%A4%8DIOS%E6%8B%8D%E7%85%A7%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98/</link>
      <guid>https://refined-x.com/2019/01/09/%E5%89%8D%E7%AB%AF%E6%A3%80%E6%B5%8B%E4%BF%AE%E5%A4%8DIOS%E6%8B%8D%E7%85%A7%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Wed, 09 Jan 2019 06:20:08 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;苹果手机竖向拍照会为照片添加左旋90度的拍照方向，导致在网页中展示异常。前端解决这个问题需要提取图片的exif信息，并检测照片的拍照方向orientation，再通过canvas绘制图片并纠正旋转方向，最后输出图片的base64。&lt;/p&gt;
&lt;p&gt;WEB前端环境可能在两种情况
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>苹果手机竖向拍照会为照片添加左旋90度的拍照方向，导致在网页中展示异常。前端解决这个问题需要提取图片的exif信息，并检测照片的拍照方向orientation，再通过canvas绘制图片并纠正旋转方向，最后输出图片的base64。</p><p>WEB前端环境可能在两种情况下遇到IOS拍照旋转问题，一是网页中通过<code>input:type=file</code>控件捕获照片文件并实时预览，二是网页中显示未经处理的苹果手机拍摄图片。</p><p><strong><a href="https://github.com/tower1229/ios-photo-repair" target="_blank" rel="external">ios-photo-repair</a></strong>是一个专门修复IOS照片旋转问题的前端工具，提供两个方法分别应对上述两种应用场景。</p><h2 id="安装ios-photo-repair"><a href="#安装ios-photo-repair" class="headerlink" title="安装ios-photo-repair"></a>安装ios-photo-repair</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i ios-photo-repair --save</span><br></pre></td></tr></table></figure><h2 id="使用ios-photo-repair"><a href="#使用ios-photo-repair" class="headerlink" title="使用ios-photo-repair"></a>使用ios-photo-repair</h2><h3 id="修复file文件"><a href="#修复file文件" class="headerlink" title="修复file文件"></a>修复file文件</h3><p><code>fixImgFile(file, [compressOption])</code>方法接收file对象和可选的压缩配置为参数，返回promise，完成后输出修复后的图片base64。如果想顺便压缩一下，还可以传入压缩配置。输出图片统一为jpeg格式，因为只有jpeg和webp格式支持压缩比设置。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"fileinput"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;fixImgFile&#125; = <span class="built_in">require</span>(<span class="string">"ios-photo-repair"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'fileinput'</span>).onchange = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> file = evt.target.files[<span class="number">0</span>]</span><br><span class="line">    fixImgFile(file, &#123;</span><br><span class="line">        width:<span class="number">500</span>,          <span class="comment">//最大宽度，默认不限制</span></span><br><span class="line">        height:<span class="number">500</span>,         <span class="comment">//最大高度，默认不限制</span></span><br><span class="line">        ratio: <span class="number">0.9</span>          <span class="comment">//压缩比，默认不压缩</span></span><br><span class="line">    &#125;).then(base64 =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(base64) <span class="comment">// 修复并压缩后的图片base64</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修复图片标签"><a href="#修复图片标签" class="headerlink" title="修复图片标签"></a>修复图片标签</h3><p><code>fixBySelector()</code>方法接收一个DOM选择器字符串为参数，用于<code>document.querySelectorAll()</code>方法获取待修复的图片元素节点，当检测到图片方向发生旋转将自动纠正并重载图片。因为<code>&lt;img&gt;</code>元素本来就已经载入到了网页中，因此没有压缩的必要，所以该方法不支持压缩配置。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/ios-1.jpg"</span> <span class="attr">id</span>=<span class="string">"iosphoto"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;fixBySelector&#125; = <span class="built_in">require</span>(<span class="string">"ios-photo-repair"</span>)</span><br><span class="line"></span><br><span class="line">fixBySelector(<span class="string">'#iosphoto'</span>)</span><br></pre></td></tr></table></figure><h2 id="项目信息"><a href="#项目信息" class="headerlink" title="项目信息"></a>项目信息</h2><p>repo: <a href="https://github.com/tower1229/ios-photo-repair" target="_blank" rel="external">https://github.com/tower1229/ios-photo-repair</a></p><h2 id="附：parceljs使用体验"><a href="#附：parceljs使用体验" class="headerlink" title="附：parceljs使用体验"></a>附：parceljs使用体验</h2><p>这个项目使用<a href="https://parceljs.org/" target="_blank" rel="external">parceljs</a>构建，第一次使用体验特别轻便，文档寥寥几页，但必要的功能一点不少，与webpack最大的区别是parceljs只关注加载和构建，资源处理都交给第三方工具去做，所以小项目起步的配置压力没有webpack那么大，做个类库之类的项目再适合不过了。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2019/01/09/%E5%89%8D%E7%AB%AF%E6%A3%80%E6%B5%8B%E4%BF%AE%E5%A4%8DIOS%E6%8B%8D%E7%85%A7%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue CLI 3 浏览器兼容性配置</title>
      <link>https://refined-x.com/2018/12/04/VueCLI3%20%E5%85%BC%E5%AE%B9%E6%80%A7%E9%85%8D%E7%BD%AE/</link>
      <guid>https://refined-x.com/2018/12/04/VueCLI3%20%E5%85%BC%E5%AE%B9%E6%80%A7%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Tue, 04 Dec 2018 10:16:17 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;开发代码兼容&quot;&gt;&lt;a href=&quot;#开发代码兼容&quot; class=&quot;headerlink&quot; title=&quot;开发代码兼容&quot;&gt;&lt;/a&gt;开发代码兼容&lt;/h2&gt;&lt;p&gt;Vue CLI
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="开发代码兼容"><a href="#开发代码兼容" class="headerlink" title="开发代码兼容"></a>开发代码兼容</h2><p>Vue CLI 3初始化的项目，构建时会根据<code>package.json</code>中的<code>browserslist</code>配置自动检测需要转译的语言特性，为构建代码转译JavaScript 并为 CSS 添加浏览器前缀，通常只需要修改<code>browserslist</code>即可兼容目标浏览器，例如兼容IE10可以做如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;: [</span><br><span class="line">    &quot;ie 10&quot;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="依赖包兼容"><a href="#依赖包兼容" class="headerlink" title="依赖包兼容"></a>依赖包兼容</h2><p>但该特性仅对源码(src/)有效，对依赖包无效，当依赖包需要做兼容性转译时，有三种选择：</p><ol><li>如果确切知道有兼容性问题的依赖包名，可以配置项目根目录下的<code>vue.config.js</code>（默认不存在），将依赖包名添加到<code>transpileDependencies</code>键中，这会为该依赖同时开启语法语法转换和根据使用情况检测 polyfill。例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    transpileDependencies: [&quot;vue-plugin-load-script&quot;]       // 需要编译的依赖包名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果确切的知道需要转译的语言特性，可以配置根目录下的<code>babel.config.js</code>，为<code>presets</code>的值添加所需要的 polyfill，例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [&apos;@vue/app&apos;, &#123;</span><br><span class="line">      polyfills: [</span><br><span class="line">        &apos;es6.symbol&apos;</span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>然而更多的情况是，我们并不确切的知道项目中引发兼容问题的具体原因，这时还可以配置为根据兼容目标导入所有 polyfill，需要设置<code>babel.config.js</code>为：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [&apos;@vue/app&apos;, &#123;</span><br><span class="line">        useBuiltIns: &apos;entry&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在入口文件（main.js）第一行添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;@babel/polyfill&apos;</span><br></pre></td></tr></table></figure><p>这种方式可能导入代码中不需要的polyfill，从而使打包体积更大。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>IE10中的node节点列表不支持<code>forEach</code>方法</li><li>IE10中background的参数中如果包括background-size参数，则background-size必须跟在background-position后面，且加上/前缀，例如：<code>background:url(./img/b.jpg) center /cover no-repeat;</code></li></ul>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/12/04/VueCLI3%20%E5%85%BC%E5%AE%B9%E6%80%A7%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTML5实现文件读取、编辑、保存</title>
      <link>https://refined-x.com/2018/09/03/HTML5%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E3%80%81%E7%BC%96%E8%BE%91%E3%80%81%E4%BF%9D%E5%AD%98/</link>
      <guid>https://refined-x.com/2018/09/03/HTML5%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E3%80%81%E7%BC%96%E8%BE%91%E3%80%81%E4%BF%9D%E5%AD%98/</guid>
      <pubDate>Mon, 03 Sep 2018 04:49:28 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;最近自己捣鼓了一个好玩的项目&lt;a href=&quot;https://github.com/tracesr&quot; target=&quot;_blank&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>最近自己捣鼓了一个好玩的项目<a href="https://github.com/tracesr" target="_blank" rel="external">觅迹导航</a>，核心功能已经开发完成，后续会抽时间完善一下细节，并开放使用。做这个项目的过程中涉及到本地文件的读写，而且项目的定位不涉及兼容性问题，所以就直接用HTML5实现了，这里将实现过程以及涉及到的知识点整理一下。</p><h2 id="HTML5读取文件"><a href="#HTML5读取文件" class="headerlink" title="HTML5读取文件"></a>HTML5读取文件</h2><p>HTML5读取文件主要利用的就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="external">FileReader</a>这个API，它的使用需要从一个构造函数开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reader = new FileReader();      // 返回一个FileReader实例</span><br></pre></td></tr></table></figure><p>返回的实例具有以下3个属性：</p><ul><li>FileReader.result</li><li>FileReader.readyState</li><li>FileReader.error</li></ul><p>其中result属性是文件读取成功后的读取结果，数据的格式取决于使用哪个方法来启动读取操作。</p><p>FileReader实例具有以下4个方法：</p><ul><li>FileReader.readAsText()</li><li>FileReader.readAsDataURL()</li><li>FileReader.readAsArrayBuffer()</li><li>FileReader.abort()</li></ul><p>前3个方法分别是以文本、图片、其他格式读取内容，读取的对象可以是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="external">Bolb</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" target="_blank" rel="external">File</a>，在读取本地文件的场景下，我们读取的实际上就是File。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader.readAsText(file);    //读取文本文件</span><br></pre></td></tr></table></figure><p>FileReader.abort()方法不需要说了，就是中断文件读取。</p><p>同时FileReader实例具有以下6个事件：</p><ul><li>FileReader.onprogress</li><li>FileReader.onloadend</li><li>FileReader.onloadstart</li><li>FileReader.onload</li><li>FileReader.onerror</li><li>FileReader.onabort</li></ul><p>其中onload事件是我们最关心的一个，该事件将在读取操作完成时触发，在这个事件中我们才能访问到FileReader.result属性，得到读取结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reader.onload = function() &#123;</span><br><span class="line">    console.log(this.result);       //文本内容</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用FileReader读取文件的整个流程就是这样，File对象我们可以通过<code>&lt;input type=&quot;file&quot; &gt;</code>获取。</p><h2 id="HTML5保存文件"><a href="#HTML5保存文件" class="headerlink" title="HTML5保存文件"></a>HTML5保存文件</h2><p>保存文件的关键是生成文件对象，可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL" target="_blank" rel="external">URL.createObjectURL()</a>方法实现，该方法能返回给定对象的URL，用在<code>&lt;a&gt;</code>标签的<code>href</code>属性上就可以创建可下载的文件链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let DownloadDom = document.getElementById(&quot;Download&quot;);      // a标签</span><br><span class="line">DownloadDom.href = window.URL.createObjectURL(myBlob);      // 生成下载链接</span><br></pre></td></tr></table></figure><p>createObjectURL()方法的参数可以是File对象或者Blob对象，前端保存文件通常是希望将已有“内容”保存成文件，这种场景我们需要的是Blob对象。</p><p>Blob构造函数可以根据传入的数组数据返回Blob对象，数组可以是ArrayBuffer、ArrayBufferView、Blob、DOMString，假如我们希望将一段JSON字符串保存成JSON文件，那么可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myBlob = new Blob([&apos;&#123;&quot;hello&quot;:&quot;world&quot;&#125;&apos;], &#123; type: &quot;application/json&quot; &#125;);     //Blob对象</span><br></pre></td></tr></table></figure><p>关于Blob构造函数的详细用法可以从<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob" target="_blank" rel="external">这里</a>了解。</p><p>有了createObjectURL和Blob，实际上，我们就可以封装一个方法，将任意字符串保存成文件，并点击链接下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let saveFile = function(fileText) &#123;</span><br><span class="line">    let DownloadDom = document.getElementById(&quot;Download&quot;);</span><br><span class="line">    if (this.DownloadDom) &#123;</span><br><span class="line">        let myBlob = new Blob([fileText], &#123; type: &quot;application/json&quot; &#125;);</span><br><span class="line">        this.DownloadDom.href = window.URL.createObjectURL(myBlob);</span><br><span class="line">        console.log(&apos;下载文件已就绪&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>结合HTML5读取文本文件功能，我们还可以实现对文本文件的编辑功能，比如JSON文件压缩，实际上就是拿到文本内容后，对内容过滤空字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fileText = reader.result;</span><br><span class="line">fileText.replace(/\s/g, &quot;&quot;);</span><br><span class="line">saveFile(fileText)</span><br></pre></td></tr></table></figure><p>再补充一点内容，createObjectURL()方法还有一个对应的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL" target="_blank" rel="external">URL.revokeObjectURL()</a>方法，用来释放生成的URL对象，用法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj_url = window.URL.createObjectURL(blob);</span><br><span class="line">var iframe = document.getElementById(&apos;viewer&apos;);</span><br><span class="line">iframe.setAttribute(&apos;src&apos;, obj_url);</span><br><span class="line">window.URL.revokeObjectURL(obj_url);</span><br></pre></td></tr></table></figure><p>当obj_url已经赋值给图片之后，就可以释放这个URL对象。这里的关键在于确定URL对象已经使用完了，在我们的例子中如果也这么做，实际上是不行的，当用户点击下载链接的时候会提示网络错误，因为href指向的链接已经失效了。猜测原因是，图片加载并显示的时候已经将数据载入内存了，这时候释放URL不会影响到图片的显示；而链接地址属于“引用”，点击瞬间会去访问URL对象，如果这时候对象已经释放了就会导致链接失效。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>HTML5实现文件读取、编辑、保存其实非常简单，只不过涉及到的API兼容性都比较堪忧，以上示例仅在chrome里测试过。</p><p>完整的示例代码地址：<br><a href="https://github.com/tower1229/htm5-file-operations" target="_blank" rel="external">https://github.com/tower1229/htm5-file-operations</a></p><p>演示地址:<br><a href="https://refined-x.com/htm5-file-operations/">https://refined-x.com/htm5-file-operations/</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/09/03/HTML5%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E3%80%81%E7%BC%96%E8%BE%91%E3%80%81%E4%BF%9D%E5%AD%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《Hybrid App开发快速指南》新课上线！</title>
      <link>https://refined-x.com/2018/08/09/%E3%80%8AHybrid%20App%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%E3%80%8B%E6%96%B0%E8%AF%BE%E4%B8%8A%E7%BA%BF/</link>
      <guid>https://refined-x.com/2018/08/09/%E3%80%8AHybrid%20App%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%E3%80%8B%E6%96%B0%E8%AF%BE%E4%B8%8A%E7%BA%BF/</guid>
      <pubDate>Thu, 09 Aug 2018 04:53:21 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;混合应用开发作为技术热点的时代已经过去了，但作为一种轻便可靠的开发手段，却早已在前端开发领域落了地。&lt;/p&gt;
&lt;p&gt;我四年前就开始从事混合应用开发，从Cordova到Appcan再到APICloud，经年累月的摸索，逐渐形成一套对前端开发者更友好的混合开发最佳实践。对于刚接
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>混合应用开发作为技术热点的时代已经过去了，但作为一种轻便可靠的开发手段，却早已在前端开发领域落了地。</p><p>我四年前就开始从事混合应用开发，从Cordova到Appcan再到APICloud，经年累月的摸索，逐渐形成一套对前端开发者更友好的混合开发最佳实践。对于刚接触混合开发的新人，与其自己摸索文档或者到论坛里发帖求助，最快的学习路径莫过于直接上手一套经过验证的方式方法。</p><p>《Hybrid App开发快速指南》这门课从去年上半年就开始筹备，起因是过去四年里我在混合开发中遇到非常多的困扰和疑问，当我试图从论坛或Q群里获取帮助时，发现这些地方根本指望不上，很多问题到最后还得靠自己摸索。所以我将自己的学习历程提炼汇总，梳理成一套课程，希望能为其他混合应用开发者带来帮助，不再经历我所经历过的迷茫。</p><p>为答谢关注公众号的朋友，最先评论公众号同名推送文章的两位读者，我将赠送免费学习名额，公众号：<a href="https://refined-x.com/programmerslife/">programmerslife（看风景）</a>。</p><p>另外还可以参加抽奖活动，中将的两位也将获得免费学习名额。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/7wyhibGKvoP0dESNeYfADG0Eo9ZBqfXYc0eQE5aXUZjE52yrTbLPhicaPA5msibTNl8m2OhVK6jZgicdwtwN4KdrvQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>感兴趣的朋友还可以扫描下方二维码，或者<a href="https://gitbook.cn/gitchat/column/5b679a1d201ffa4ab88e7d5d" target="_blank" rel="external">点此链接</a>学习课程。</p><p><img src="https://refined-x.com/asset/course-hybrid.png" alt=""></p><h2 id="附：课程介绍"><a href="#附：课程介绍" class="headerlink" title="附：课程介绍"></a>附：课程介绍</h2><p>本课程为混合应用开发入门课程，将带领读者快速掌握 Hybrid App 开发能力，内容涵盖混合应用原理、混合应用开发基础、混合应用开发进阶、混合应用开发最佳实践。</p><p>课程主要分为两大部分：</p><p>第一部分（第01-05课），理论篇，带大家明确了解混合应用开发与普通 Web 前端开发的差异，内容包括混合应用原理、混合应用界面开发、混合应用体验优化、性能优化、混合应用安全性等，属于混合应用开发基础理论内部。</p><p>第二部分（第06-13课），实战篇，从技术选型开始，讲解如何基于 APICloud 平台开发混合应用，内容包括平台特性、前端项目工程规划、界面交互、数据交互、数据缓存等开发中的各个方面，并将遇到的所有需求一一封装，最终将带你从零搭建一套混合应用开发框架。<br>课程以实战干货为主，在保证学习连贯性的前提下，尽量减少文档可查、引擎可搜的内容。通过认真学习本课程，读者将对混合应用开发有深入的理解，并有能力基于 APICloud 平台快速开发跨平台混合应用。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/08/09/%E3%80%8AHybrid%20App%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%E3%80%8B%E6%96%B0%E8%AF%BE%E4%B8%8A%E7%BA%BF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>基于Vue实现动态组织结构图</title>
      <link>https://refined-x.com/2018/08/03/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE/</link>
      <guid>https://refined-x.com/2018/08/03/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE/</guid>
      <pubDate>Fri, 03 Aug 2018 09:36:23 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;Vue-Tree-Chart&quot;&gt;&lt;a href=&quot;#Vue-Tree-Chart&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Vue-Tree-Chart"><a href="#Vue-Tree-Chart" class="headerlink" title="Vue-Tree-Chart"></a>Vue-Tree-Chart</h2><p>最近一个项目里有个前端绘制家谱图的需求，大概是下面这个样子：</p><p><img src="https://refined-x.com/asset/vue-tree-chart.png" alt=""></p><p>点击节点会弹出操作菜单，实现增删改查等操作，查阅网上资料发现，现有案例基本都是基于<a href="http://www.getorgchart.com/" target="_blank" rel="external">orgchart</a>这个jQuery插件实现的，我们的项目是基于Vue的，不希望因为这个功能引入jQuery，所以就基于Vue实现了一个简易版的树形图/组织结构图组件：<a href="https://github.com/tower1229/Vue-Tree-Chart" target="_blank" rel="external">Vue-Tree-Chart</a>。</p><p><a href="https://github.com/tower1229/Vue-Tree-Chart" target="_blank" rel="external">Vue-Tree-Chart</a>实现了最核心的组织结构图动态绘制和点击节点回调，基于这两点已经可以满足绝大多数相关需求了，例如前端动态增删改，无非是编辑组件数据，利用Vue的数据驱动特性界面就会自动更新；服务端增删改就更简单了，前端只管请求操作接口，操作结束后拉取最新数据同步给组件就行了；组件默认界面非常简单，只引入了图表呈现所必须的少量样式，后期非常方便自定义风格；至于拖动、缩放、导出等不太普遍的需求，组件没有内置，但是在源码基础上实现这些扩展也都比较简单。</p><h2 id="如何绘制结构图"><a href="#如何绘制结构图" class="headerlink" title="如何绘制结构图"></a>如何绘制结构图</h2><h3 id="不靠谱的思路"><a href="#不靠谱的思路" class="headerlink" title="不靠谱的思路"></a>不靠谱的思路</h3><p>拿到这个需求后我首先想到的思路是用DIV布局+JS动态计算实现，如果不考虑节点连线的话，这个思路其实勉强也能应付，大致实现分为三步：</p><h4 id="一、将数据按“代”拆分"><a href="#一、将数据按“代”拆分" class="headerlink" title="一、将数据按“代”拆分"></a>一、将数据按“代”拆分</h4><p>原始数据格式只能是层层深入的JSON对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &apos;root&apos;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">        name: &apos;child&apos;,</span><br><span class="line">        children: [&#123;</span><br><span class="line">            name: &apos;grandchild&apos;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按“代”拆分后成为这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [&#123;</span><br><span class="line">        id: 0,</span><br><span class="line">        name: &apos;root</span><br><span class="line">    &#125;],</span><br><span class="line">    [&#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        name: &apos;child&apos;,</span><br><span class="line">        pid: 0</span><br><span class="line">    &#125;],</span><br><span class="line">    [&#123;</span><br><span class="line">        id: 2</span><br><span class="line">        name: &apos;grandchild&apos;,</span><br><span class="line">        pid: 1</span><br><span class="line">    &#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>形象一点，我想要的其实是这种结构：</p><p><img src="https://refined-x.com/asset/nodes-1.png" alt=""></p><h4 id="二、按“代”绘制节点"><a href="#二、按“代”绘制节点" class="headerlink" title="二、按“代”绘制节点"></a>二、按“代”绘制节点</h4><p>有了上一步的数据，再将每一代的节点从上到下生成出来简直不要太容易，然后居中一下，树形结构基本就出来了：</p><p><img src="https://refined-x.com/asset/nodes-2.png" alt=""></p><p>这时节点的间距是相同的，我们需要在下一步中计算并更新节点间距，使他们呈现出正确的归属关系。</p><h4 id="三、计算节点间距"><a href="#三、计算节点间距" class="headerlink" title="三、计算节点间距"></a>三、计算节点间距</h4><p>我们需要的是这样的效果：</p><p><img src="https://refined-x.com/asset/nodes-3.png" alt=""></p><p>观察图形得知，除了初代节点始终居中之外，其他节点所占空间应该等于后代节点所占空间，所以我们需要从最后一代节点开始遍历，依次向上得到父级节点应该占据的空间，从而计算出其需要的左右<code>marin</code>值，将所有包含子节点的节点应用正确的<code>margin</code>后，应该就可以得到上图的效果。</p><p>另外，家谱图还需要节点间连线，如果仍然按照这个思路，用div模拟画线也可以，但这样一来计算逻辑的复杂度就比较大了，这时候已经明显感觉思路不对了，必须换方向。</p><h3 id="Table的妙用"><a href="#Table的妙用" class="headerlink" title="Table的妙用"></a>Table的妙用</h3><p>后来参考orgchart的实现，打开调试工具一看，怎么里面一大堆<code>&lt;table&gt;</code>标签，心想这是什么骚操作，后来仔细研究DEMO的标签结构，原来orgchart非常巧妙的利用了Table标签的特性，只要合理嵌套Table，浏览器就会自然渲染出我们需要的结果。</p><p>这里补充一下Table的背景知识，在DIV+CSS刚刚盛行的年代，Table布局因为渲染慢和代码冗余被所有前端集体唾弃，Table布局渲染慢的原因是，TD是唯一一个先进入文档可能被后进入文档影响到自身尺寸的标签，如果按照普通的页面渲染逻辑加载整页Table，就会随着TD标签的载入频繁触发页面重绘，浏览器为了避免这种情况所以会对Table采用特殊的绘制逻辑，也就是等整个Table标签全部加载完，再集中一次绘制到页面上。这样的结果就是当页面完全使用Table布局的时候，整个页面加载过程是空白的，加载完之后页面会一次性突然呈现，这在弱网情况下的用户体验非常差，因此不使用Table布局成了对前端开发最基本的要求。</p><p>Table的这种特性虽然不适合用来布局，但却使Table成了HTML中“最强大”的标签，比如前面我们梳理的树形插件的实现思路，其实就是对Table特性的拙劣模仿，一个多代组织结构关系完全可以只用Table标签完美实现，甚至连CSS都不需要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td colspan=&quot;2&quot;&gt;</span><br><span class="line">            root</span><br><span class="line">        &lt;/td/&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;table&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        children1</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &lt;table&gt;</span><br><span class="line">                            &lt;tr&gt;</span><br><span class="line">                                &lt;td colspan=&quot;2&quot;&gt;</span><br><span class="line">                                    children2</span><br><span class="line">                                &lt;/td&gt;</span><br><span class="line">                            &lt;/tr&gt;</span><br><span class="line">                            &lt;tr&gt;</span><br><span class="line">                                &lt;td&gt;</span><br><span class="line">                                    grandchild1</span><br><span class="line">                                &lt;/td&gt;</span><br><span class="line">                                &lt;td&gt;</span><br><span class="line">                                    grandchild2</span><br><span class="line">                                &lt;/td&gt;</span><br><span class="line">                            &lt;/tr&gt;</span><br><span class="line">                        &lt;/table&gt;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>虽然结构很罗嗦，但确实能实现需求。</p><p>节点连线的实现同样是利用了Table的自适应性，只不过实现的更加精妙：</p><p><img src="https://refined-x.com/asset/nodes-4.png" alt=""></p><p>上下级的连线分成两行（TR）实现，第一行实现一个连结父节点的居中竖线，第二行实现连接每个子节点的竖线及横向连线，第一行比较简单这里不提，第二行的实现非常有意思，上图中画红框的部分分别是实现效果和标签结构。</p><p>首先按照子节点数量X2来生成TD标签，然后”rightLine”、”leftLine”交替为每个TD添加class，”rightLine”为TD显示1px的右边线，”leftLine”为TD显示1px的左边线，六根一右一左的线两两合并在一起，正好呈现出三条连接每个子节点正中的2px竖线；然后除了第一个和最后一个TD标签以外，全部添加”topLine”的class，为他们添加2px的上边线，这样会呈现出一条正好连接三条竖线的横线，再拼上第一行TR的居中竖线，上下级的连线就实现出来了。</p><p>看到这部分时，反正我是感觉自己的智商被碾压了。（这部分在1.1.0版本中被重构掉了，因为用伪元素实现连线更方便）</p><p>基于这个思路用Vue实现了一遍，独立成组件后<a href="https://github.com/tower1229/Vue-Tree-Chart/blob/master/lib/components/TreeChart.vue" target="_blank" rel="external">整个文件</a>代码不过百行左右。</p><p>另外知识的活学活用真的非常重要，这里面的知识点一个入门前端就应该掌握，但开发的时候却完全没有想到这个思路，可能跟近几年的工作大量依赖js有关系，对HTML和CSS的敏感性降低了。总是使用自己熟悉的方式解决问题是人的共性，但这一点对开发者来说绝对不是个好习惯，需要反省。</p><h2 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h2><p>Vue-Tree-Chart已经发布到npm，默认可以通过包管理工具将其添加到项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-tree-chart --save</span><br></pre></td></tr></table></figure><p>但npm安装的是编译后的版本，如果希望比较灵活的在项目中做二次开发，可以直接将<code>&#39;lib/components/TreeChart.vue&#39;</code>文件下载到项目的组件目录（<code>&#39;src/components/&#39;</code>），直接修改<code>TreeChart.vue</code>文件就可以了。</p><h2 id="vue-cli-3-0-构建库"><a href="#vue-cli-3-0-构建库" class="headerlink" title="vue-cli 3.0 构建库"></a>vue-cli 3.0 构建库</h2><p>最后提一下vue-cli 3.0的<a href="https://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%94%E7%94%A8" target="_blank" rel="external">构建目标</a>功能，为了方便组件开发者，vue-cli 3.0在常规构建之外单独提供了针对库和Web Components组件两种构建模式，现在开发Vue插件/组件再也不需要手动修改webpack配置了，只要为构建命令传入<code>target\name\entry</code>，就能自动将入口文件编译成库，并输出CommonJS、浏览器环境所需要的一系列文件。</p><p>例如Vue-Tree-Chart的package.json文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;./dist/TreeChart.common.js&quot;,</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build-bundle&quot;: &quot;vue-cli-service build --target lib --name TreeChart ./lib/index.js&quot;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>执行<code>npm run build-bundle</code>就会在<code>&#39;/dist&#39;</code>目里下生成一系列产出文件，其中<code>&quot;TreeChart.common.js&quot;</code>是webpack环境下需要的CommonJS包，将这个文件配置为<code>&#39;main&#39;</code>，就可以在项目中这样使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import TreeChart from &quot;vue-tree-chart&quot;;</span><br></pre></td></tr></table></figure><p>导入的TreeChart对象就是一个Vue Component，可以作为全局组件或者局部组件挂载使用。</p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>Vue-Tree-Chart项目地址：<a href="https://github.com/tower1229/Vue-Tree-Chart" target="_blank" rel="external">https://github.com/tower1229/Vue-Tree-Chart</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/08/03/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何计算一款保险的杠杆</title>
      <link>https://refined-x.com/2018/07/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AC%BE%E4%BF%9D%E9%99%A9%E7%9A%84%E6%9D%A0%E6%9D%86/</link>
      <guid>https://refined-x.com/2018/07/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AC%BE%E4%BF%9D%E9%99%A9%E7%9A%84%E6%9D%A0%E6%9D%86/</guid>
      <pubDate>Mon, 02 Jul 2018 07:06:20 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这篇文章向大家分享一个复利计算小工具，用来模拟保险年缴保费的支出情况，并用复利的方式算出这些保费在相同年数里的理财收入，技术含量极低，但如果你像我一样近期有买保险需求的话，这个小工具可以帮助你快速衡量一款保险产品的投入产出杠杆。</p><h2 id="聊聊保险"><a href="#聊聊保险" class="headerlink" title="聊聊保险"></a>聊聊保险</h2><p>自从宝宝出生后，突然感觉自己的健康风险特别高，为什么呢，说白了就一个原因：<strong>收入来源单一</strong>，孩子在不断长大，父母在不断老去，家庭支出在可预见的未来越来越高，这时候作为家庭经济支柱的自己如果出了问题，后果不堪设想，所以有一天我的脑子里突然响起一个声音：我要买保险。说到保险很多人第一反应是<code>骗子、坑、水深、感觉没啥用</code>，这也是我曾经的想法，但当有一天你也看到自己珍视的东西暴露在不可承受的风险之下时，可能也会重新考虑保险这件事。其实<strong>保险的本质是杠杆</strong>，这个杠杆允许你交一小笔钱，待出现风险时拿到一笔大钱，帮助家庭度过难关。在这个本质的基础上，如今的保险产品衍生出了太多花样，我花了不少时间才大致理清一个脉络，这里就不展开说了。</p><h2 id="定投复利计算器"><a href="#定投复利计算器" class="headerlink" title="定投复利计算器"></a>定投复利计算器</h2><p>前面大致说了这个计算器是干什么用的，这里再详细解释一下。以我自己为例，准备买人生第一款商业保险，重疾险，对于暂时手头没有那么宽裕的人（===穷人）来说，只能选择消费型、低保额、保终身，于是就锁定了全网最便宜的消费型重疾险<a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external">百年康惠保</a>，保额我打算先来30万，以后宽裕了再增加（maybe），缴费年限越长年费越少（总额会多一些），老夫已经30了，希望20年内缴完，所以保费情况是这样的：</p><p><a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external"><img src="https://refined-x.com/asset/baofei-kanghuibao.png" alt="此处输入图片的描述"></a></p><p>每年缴3390元，缴费20年，那么此时我最想知道，同样的时间和金钱付出，如果用在普通理财产品上会有怎样的收益？假设自己可以通过理财达到跟保险保额差不太多的收益，那显然就不需要买保险了。OK，我平时工资一般就放在微信钱包-零钱通里，年化收益率大致4%，如果我把每年要缴给保险公司的3390元都放进零钱通，20年后我一共有多少钱？算法很简单，第一年投入的年费作为初始本金，到年底会获得4%的受益，然后连本带息再加上第二年的年费一起作为第二年的本金，继续按照4%的收益率计算年底收益，以此类推直到20年，得到最终结果。</p><p><a href="//refined-x.com/projects/codes/interest.html">复利计算器</a>就是用来做这件事的，最终计算结果为104983，也就是10万出头，而这款产品的保额是30万，那么可以得出结论，以我的理财能力这款保险的保费杠杆可以达到3倍，这基本上是市面上杠杆最高的了，看来全网最便宜果然名不虚传。</p><p><img src="https://refined-x.com/asset/interest.png" alt="此处输入图片的描述"></p><p>感兴趣的可以自己来算算：<a href="//refined-x.com/projects/codes/interest.html">复利计算器</a>。</p><p>这里衍生一个话题，就是什么人不需要买保险？我觉得有两种人，第一是理财收益率能达到13%的人，因为通过计算得知，只要保持这个收益率就能将<a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external">“全网最便宜的消费型重疾险”</a>的杠杆拉平，获得跟保费大致相同的收益，但是理财讲究资金的规模效应，以多数人的资金水平不可能稳定实现这么高的收益率；第二种人可能就是所谓生意人了，把钱投入商业运作，得到多高的收益都不稀奇，难点在于稳定。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>计算器的具体实现实在太简单就不提了，有兴趣的可以自己打开调试工具看源码。这里想多说两句，大家买保险千万不要凭感觉去买，很多人不喜欢纯消费型保险，认为如果自己好人一生平安就相当于把钱白给保险公司了，首先这是事实，你得到了你需要的保障，保险公司得到了利润，天经地义，也因此保险才是一个双赢产品，得以经久不衰的经营下去。由于这种“吃亏”心理非常普遍，因此市面上带返还的产品非常受欢迎，比如有的产品会在65周岁时反保额，看上去好像很划算，其实自己算一下就知道，去掉返现以后你的总投入一点不比消费型产品少，因为这期间动辄几十年的时间，你的本金会源源不断的产生收益，正所谓时间就是金钱。</p><hr><p><a href="//refined-x.com/projects/codes/interest.html">复利计算器</a></p><p><a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external">“全网最便宜的消费型重疾险”</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/07/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AC%BE%E4%BF%9D%E9%99%A9%E7%9A%84%E6%9D%A0%E6%9D%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HybridStart v1.2.0 更新日志</title>
      <link>https://refined-x.com/2018/04/27/HybridStart%20v1.2.0%20%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</link>
      <guid>https://refined-x.com/2018/04/27/HybridStart%20v1.2.0%20%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Fri, 27 Apr 2018 08:53:15 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;新增&quot;&gt;&lt;a href=&quot;#新增&quot; class=&quot;headerlink&quot; title=&quot;新增&quot;&gt;&lt;/a&gt;新增&lt;/h2&gt;&lt;h3 id=&quot;1-插件机制&quot;&gt;&lt;a href=&quot;#1-插件机制&quot; class=&quot;headerlink&quot; title=&quot;1.
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><h3 id="1-插件机制"><a href="#1-插件机制" class="headerlink" title="1. 插件机制"></a>1. 插件机制</h3><p>WEB代码无需编译，部署即可运行，因此可以很容易的实现热插拔插件机制，HybridStart内置了一个插件机制的实现DEMO，见示例APP首页“OTA-plugins(扩展插件)”。实现代码位于<code>/views/ota/</code>，额外引入了<a href="https://docs.apicloud.com/Client-API/Func-Ext/zip" target="_blank" rel="external">zip</a>模块实现插件压缩包的解压，完整流程如下：</p><p><img src="http://refined-x.com/asset/hybridstart-plugin.png" alt=""></p><p>插件列表数据格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;status&quot;: &quot;Y&quot;,</span><br><span class="line">&quot;data&quot;: [&#123;</span><br><span class="line">&quot;remote&quot;: &quot;http://static-zt.oss-cn-qingdao.aliyuncs.com/mock/plugin-test.zip&quot;,//插件压缩包下载地址</span><br><span class="line">&quot;index&quot;: &quot;/view/index/temp.html&quot;,//插件首页路径</span><br><span class="line">&quot;name&quot;: &quot;plugin-test&quot;,//插件名称（唯一标识）</span><br><span class="line">&quot;showName&quot;: &quot;测试插件&quot;//插件展示名称</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;remote&quot;: &quot;http://static-zt.oss-cn-qingdao.aliyuncs.com/mock/plugin-refined-x.zip&quot;,</span><br><span class="line">&quot;index&quot;: &quot;/view/index/temp.html&quot;,</span><br><span class="line">&quot;name&quot;: &quot;plugin-refined-x&quot;,</span><br><span class="line">&quot;showName&quot;: &quot;下载失败测试&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;msg&quot;: &quot;获取插件成功&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对插件包的文件结构没有要求，只需要在插件数据中正确指定首页即可，每个插件都自成一体，无法调用App的脚本文件。示例没有实现插件的删除，实际应用中可以自行实现删除功能。</p><h3 id="2-UI支持沉浸式"><a href="#2-UI支持沉浸式" class="headerlink" title="2. UI支持沉浸式"></a>2. UI支持沉浸式</h3><p>对<code>ui.less</code>做了调整，可以很容易的适配沉浸式效果，只需要给<code>.head类</code>加上<code>padding-top:24px</code>，编译成<code>ui.css</code>即可。开启沉浸式体验可以修改<code>config.xml</code>中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;preference name=&quot;statusBarAppearance&quot; value=&quot;true&quot;/&gt;//默认false</span><br></pre></td></tr></table></figure><h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><h3 id="1-移除页面style-css文件"><a href="#1-移除页面style-css文件" class="headerlink" title="1. 移除页面style.css文件"></a>1. 移除页面style.css文件</h3><p>考虑到页面独有样式通常不多，所以从页面文件夹中移除style.css文件，页面样式可以直接写在<code>temp.html</code>头部，减少文件引用，提升页面加载速度。</p><h3 id="2-增加loader-js"><a href="#2-增加loader-js" class="headerlink" title="2. 增加loader.js"></a>2. 增加loader.js</h3><p>将原来页面底部的一大坨异步非阻塞加载脚本的代码整理成<code>loader.js</code>统一调用。所谓异步非阻塞的意思是绕过APICloud的加载等待机制，使新开窗口能第一时间进场，在进场动画过程中加载页面脚本，以提升页面进场动画的响应速度。</p><p>由此带来的问题是页面脚本只能在真机环境下运行，让js调试非常不方便，关于调试方面的建议可以参考<a href="https://refined-x.com/HybridStart/docs/#solution-speed">进场动画提速</a></p><h2 id="BUG-修复"><a href="#BUG-修复" class="headerlink" title="BUG 修复"></a>BUG 修复</h2><h3 id="1-IOS事件委托BUG"><a href="#1-IOS事件委托BUG" class="headerlink" title="1. IOS事件委托BUG"></a>1. IOS事件委托BUG</h3><p>这个BUG的复现条件为，在IOS环境下将多个页面元素（比如列表项）的点击事件委托在body元素上，当元素多到足以页面发生滚动时，非首屏的元素将不响应点击事件。框架在<code>common.js</code>中默认提供的<code>[active]</code>跳转属性受到该BUG影响，示例APP的首页列表在IOS上会出现非首屏内容无法点击的问题。</p><p>解决方法为在body里插入一个<code>div#body</code>元素，将事件委托改在这个元素上就OK了，<code>common.js</code>里的事件委托写法做了如下兼容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var $body = $(&apos;#body&apos;).length ? $(&apos;#body&apos;) : $(&apos;body&apos;);//优先查找div#body元素</span><br><span class="line">$body.on(...</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-移除默认数据格式约定"><a href="#1-移除默认数据格式约定" class="headerlink" title="1. 移除默认数据格式约定"></a>1. 移除默认数据格式约定</h3><p>不再约定默认的异步数据格式，<code>app.ajax()</code>中已经移除数据格式校验相关代码。</p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p><a href="http://app.mi.com/details?id=com.apicloud.A6997660453388" target="_blank" rel="external">体验APP</a></p><p><a href="https://github.com/tower1229/HybridStart" target="_blank" rel="external">代码仓库</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/04/27/HybridStart%20v1.2.0%20%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AJAX-Cache：一款好用的Ajax缓存插件</title>
      <link>https://refined-x.com/2018/03/07/AJAX-Cache/</link>
      <guid>https://refined-x.com/2018/03/07/AJAX-Cache/</guid>
      <pubDate>Wed, 07 Mar 2018 01:29:37 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;AJAX-Cache是什么&quot;&gt;&lt;a href=&quot;#AJAX-Cache是什么&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="AJAX-Cache是什么"><a href="#AJAX-Cache是什么" class="headerlink" title="AJAX-Cache是什么"></a>AJAX-Cache是什么</h2><p>Ajax是前端开发必不可少的数据获取手段，在频繁的异步请求业务中，我们往往需要利用“缓存”提升界面响应速度，减少网络资源占用。AJAX-Cache是一款jQuery缓存插件，可以为<code>$.ajax()</code>方法扩展缓存功能。</p><h2 id="AJAX-Cache提供什么"><a href="#AJAX-Cache提供什么" class="headerlink" title="AJAX-Cache提供什么"></a>AJAX-Cache提供什么</h2><h3 id="1-定时缓存"><a href="#1-定时缓存" class="headerlink" title="1. 定时缓存"></a>1. 定时缓存</h3><p>大多数的缓存场景是，希望将某个接口数据在一定时间段内缓存起来，缓存期内不再发起请求直接返回本地数据，过了这段时间再重新获取并更新缓存。</p><p>这就是“定时缓存”的典型使用场景，我们可以为<code>$.ajax()</code>方法传入<code>localCache: Number</code>开启定时缓存，Number是缓存秒毫秒数。定时缓存实际上是牺牲了数据实时性换取响应速度，使用中通过设置不同的缓存时长，可以匹配不同的业务场景，比如对于相对稳定的数据可以设置较长的缓存时间，而设置较短的缓存时间则可以起到请求“防抖”作用。</p><h3 id="2-快照缓存"><a href="#2-快照缓存" class="headerlink" title="2. 快照缓存"></a>2. 快照缓存</h3><p>更多的时候我们希望接口能兼具实时性和响应速度，比如应用首屏的异步数据块，既要快又要新，虽然这种需求听起来很“不科学”，但我们确实可以通过“快照缓存”满足这个需求。</p><p>为<code>$.ajax()</code>方法传入<code>localCache: &quot;snapshot&quot;</code>可以开启快照缓存，此时每当接口成功请求后都会为数据建立一份“快照”，下次请求时接口会首先将最近的快照数据作为结果返回，供前端渲染界面，同时发送请求获取最新数据，新数据到达后会与快照做对比，如果与快照相同则缓存命中，如果与快照不同会更新快照，并将新数据返回，供前端更新界面。也就是说启用快照缓存的接口前端有可能得到两次返回结果，为了让前端能够区分出快照，对象格式的快照数据会自动增加一个<code>snapshot=true</code>的属性。</p><h3 id="3-缓存清理"><a href="#3-缓存清理" class="headerlink" title="3. 缓存清理"></a>3. 缓存清理</h3><p>插件本身会自动清理过期缓存；</p><p>对于不想继续使用缓存的接口可以为<code>$.ajax()</code>方法传入<code>localCache: false</code>清理当前接口的缓存并返回最新数据；</p><p>也可以调用<code>$.ajaxCache.clear()</code>清理所有AJAX-Cache插件产生的缓存。</p><h3 id="4-并发管理"><a href="#4-并发管理" class="headerlink" title="4. 并发管理"></a>4. 并发管理</h3><p>除了上述基本功能，AJAX-Cache还考虑到了极端情况下的请求并发问题，当某个接口在本地没有缓存或者缓存过期时发生了并发，AJAX-Cache会拦截并发请求，暂存请求回调，只向服务端发送一次请求，待拿到数据后再依次执行暂存的请求回调，从而真正起到减少网络资源占用的作用。</p><h3 id="5-约定优于配置"><a href="#5-约定优于配置" class="headerlink" title="5. 约定优于配置"></a>5. 约定优于配置</h3><p>最后，Ajax-Cache奉行“约定优于配置”的理念，将主要功能都集中到一个<code>localCache</code>配置上，使用简单，将对业务代码的侵入性降到最低，如果没有使用<code>$.ajaxCache</code>全局方法的话，从页面中直接将Ajax-Cache插件移除业务代码也不会报错。</p><p>使用简单不代表功能简单，如果需要修改Ajax-Cache的全局配置，也可以通过<code>$.ajaxCache.set(config[Object])</code>方法实现，目前有两个配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">storage: &apos;localStorage&apos;, //存储方式，默认localStorage，可选sessionStorage</span><br><span class="line">cacheNamePrefix: &apos;_ajaxcache&apos; //存储标识，集中清理缓存时的依据，如果与你存储的业务数据发生冲突，可以通过这里修改</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展信息"><a href="#扩展信息" class="headerlink" title="扩展信息"></a>扩展信息</h2><p>官网：//refined-x.com/AJAX-Cache/<br>Github：<a href="https://github.com/tower1229/AJAX-Cache" target="_blank" rel="external">https://github.com/tower1229/AJAX-Cache</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/03/07/AJAX-Cache/#disqus_thread</comments>
    </item>
    
    <item>
      <title>前端页面热更新实现方案</title>
      <link>https://refined-x.com/2018/02/07/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</link>
      <guid>https://refined-x.com/2018/02/07/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Wed, 07 Feb 2018 02:46:48 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前端页面热更新&quot;&gt;&lt;a href=&quot;#前端页面热更新&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前端页面热更新"><a href="#前端页面热更新" class="headerlink" title="前端页面热更新"></a>前端页面热更新</h2><p>了解过前端性能优化的同学应该清楚，给页面加载提速的终极方案就是CDN，这是BS架构本身的特点决定的，无论什么前端提速手段，最终都会回到客户端文件的传输上来；与之相对的CS架构则不存在加载压力，但CS架构的问题是更新不灵活，那么有没有一种方法能结合这两种架构的优点，在加载速度和更新灵活性之间找到一个平衡点呢？这就是本文要探讨的一种方案：前端热更新。</p><h2 id="方案概述"><a href="#方案概述" class="headerlink" title="方案概述"></a>方案概述</h2><p>“前端”和“热更新”这两个词通常很少一起出现，提到热更新一般都是指APP的一种静默更新方式，这种方式会在用户使用时悄悄检测并下载增量更新包，当用户下次打开APP时自动应用更新，从而将APP“更新”这个破坏连贯性的动作隐藏于无形；前端页面的加载则相当于每次都是“全量更新”，如果能让前端页面也能用上“本地模板”，那将极大缩短前端加载时间，而且以此为前提，我们也可以实现一个前端的模板热更新机制，做到不影响页面更新的实时性。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>场景一：APP内嵌页面。</p><p>比如电商类APP的首页，经常需要改版或者做活动皮肤，如何减少更新成本就成了一个大问题。使用了热更新方案我们就可以用HTML实现APP首页，页面内容以模板的形式存进localStorage，后台静默更新模板，下次启动自动生效；针对具有一定时效性的活动皮肤，我们以补丁的形式发布，补丁文件叠加在模板上产生最终的活动模板效果，对于补丁包我们可以提前加载并预存在本地，补丁包应该包含自身的生效时段信息，前端检测到时间处于活动周期内时应用补丁。最终可以做到热更新页面无论改版还是做活动，只需要前端发版就可以，完全不需要APP端参与。</p><p>场景二：追求加载速度的web页面。</p><p>对于web页面来说更新不是问题，加载才是最大的问题，如果个别页面希望极致提升页面展现速度，那么也可以使用该方案作为提速手段，但因为页面的所有代码都将存进localStorage，所以不适合大范围使用。</p><h3 id="需求细化"><a href="#需求细化" class="headerlink" title="需求细化"></a>需求细化</h3><p>综合以上场景和需求，最终我们要做的东西是一个“壳”页面，该页面没有具体业务内容，只实现热更新功能，每次加载都先检查localStorage中是否存在模板，如果有则立即应用模板，此时页面展现出来，如果没有则进入下一步；下一步页面会请求模板管理接口获取最新模板信息，拿到模板信息后如果本地已有模板，则与本地模板比对版本信息，如果版本一致说明缓存命中，流程结束；如果本地版本不是最新，则获取最新模板并存进本地，下次页面加载时将应用最新的模板，流程结束；另一种情况是首次加载本地没有任何模板，那么将获取最新模板，保存到本地，然后应用模板，流程结束。</p><p>前面说的是稳定模板的更新流程，稳定模板流程结束后会进入补丁模板更新流程。首先仍然是检查本地是否存在补丁模板，如果已存在则检测当前时间是否匹配补丁的生效时段，匹配则应用补丁，不匹配将进入下一步；下一步将获取最新补丁模板并存到本地，然后检测当前时间是否匹配最新补丁的生效时段，如果匹配则应用模板，不匹配流程结束。</p><p>完整流程如图所示：<br><img src="https://refined-x.com/asset/hot-patch.png" alt="hot patch"></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="接口数据"><a href="#接口数据" class="headerlink" title="接口数据"></a>接口数据</h3><p>根据功能需求我们需要接口返回稳定模板信息和活动模板信息，分别都包含<code>id</code>和<code>url</code>两个字段，<code>id</code>用于版本校验，<code>url</code>指向模板文件下载地址，活动模板信息还需要额外提供<code>cycle</code>字段，定义活动模板的生效时段，与之相对的我们还需要接口返回服务器当前时间，用于匹配活动模板的生效时段，最终完整的数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;status&quot;: &quot;Y&quot;,</span><br><span class="line">&quot;data&quot;: &#123;</span><br><span class="line">&quot;stableVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;17&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;activeVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;18&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;,</span><br><span class="line">&quot;cycle&quot;: &quot;2018,02,01-2018,02,10&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;today&quot;: &quot;2018,02,06&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本地数据"><a href="#本地数据" class="headerlink" title="本地数据"></a>本地数据</h3><p>保存到本地的数据大致跟接口数据保持一致，只保留<code>stableVersion</code>和<code>activeVersion</code>信息，字段在<code>id</code>和<code>url</code>基础上再增加<code>template</code>用于保存模板字符串，完整本地数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;stableVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;17&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;,</span><br><span class="line">&quot;template&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;activeVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;18&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;,</span><br><span class="line">&quot;cycle&quot;: &quot;2018,02,01-2018,02,10&quot;,</span><br><span class="line">&quot;template&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h3><p>前端页面由三种语言构成，但我们希望只用一次请求就把模板文件拿到，所以模板是一个包含了html/css/js的文本文件，标签格式就保持普通HTML文件的写法，考虑到模板应用部分的实现，需要约定一下标签的写法，例如css必须用<code>&lt;style&gt;&lt;/style&gt;</code>标签包裹，js必须用<code>&lt;script style=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>标签包裹，这样一来用正则表达式就很容易提取到各部分代码段。</p><h3 id="模板应用"><a href="#模板应用" class="headerlink" title="模板应用"></a>模板应用</h3><p>如上段所说，获得模板文件后可以使用正则表达式拿到三种语言代码，然后只需要按照css &gt; html &gt; js的顺序依次将他们插入页面相应位置，就完成了模板应用，唯一不同的是html代码将以<code>innerHTML</code>的方式覆盖进body元素。在应用顺序上，将css放在html之前是为了避免重绘，将js放在html之后是为了能够在js中操作DOM。</p><p>活动模板虽然定义为补丁，但模板构成跟稳定模板其实是相同的，应用方式也完全相同，只不过由于活动模板在稳定模板之后应用，所以活动模板的css和js都将以补丁的方式影响页面，对于普通的换皮肤需求只需要css和js就足够了，但如果希望html也能发生一些改变，根据html的覆盖式应用方式，活动模板中就需要给出一份完整的html代码，以达到修改html的目的。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><h3 id="示例展示"><a href="#示例展示" class="headerlink" title="示例展示"></a>示例展示</h3><p><a href="//refined-x.com/WEB-OTA/">//refined-x.com/WEB-OTA/</a></p><p><img src="https://refined-x.com/asset/web-ota-qrcode.png" alt="qrcode"></p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p><a href="http://o2o.zhongyishijia.com/" target="_blank" rel="external">一健康网上商城</a>APP首页即采用WEB-OTA方案实现，应付日常迭代游刃有余。</p><p><img src="https://refined-x.com/asset/yijiankang-share.png" alt="yijiankang"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>整个方案的流程比较琐碎，但实现过程其实很简单，部署成本也不高，只需要后端把模板管理起来，再提供一个更新接口就行了，但这套更新机制还是有一个小问题，那就是当有新版本发布时用户并不能第一时间看到新版本，必须下次访问才能更新到新版本，这算是静默更新要付出的一点点代价吧，如果实在介意这个问题其实也容易解决，只需要在检测到远程有新版本时提示用户重启/刷新就可以了。</p><p>相比较HTML5的manifest缓存方案，我认为灵活性要更高一些，但不足之处在于不支持静态文件的碎片化管理，但扩展这个功能也不复杂，无非模板信息里再扩展几个字段而已。</p><p>代码在这里了，更细节的东西自己看代码吧：<a href="https://github.com/tower1229/WEB-OTA" target="_blank" rel="external">https://github.com/tower1229/WEB-OTA</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/02/07/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue2.0用户权限控制解决方案</title>
      <link>https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <guid>https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Tue, 28 Nov 2017 08:39:21 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;&lt;a href=&quot;//refined-x.com/Vue-Access-Control/&quot;&gt;Vue-Access-Control&lt;/a&gt;是一套基于Vue/Vue-Router/axios
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="//refined-x.com/Vue-Access-Control/">Vue-Access-Control</a>是一套基于Vue/Vue-Router/axios 实现的前端用户权限控制解决方案，通过对路由、视图、请求三个层面的控制，使开发者可以实现任意颗粒度的用户权限控制。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h3><ul><li>Vue 2.0x</li><li>Vue-router 3.x</li></ul><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>项目主页：https//refined-x.com/Vue-Access-Control/</p><p>git：<code>git clone https://github.com/tower1229/Vue-Access-Control.git</code></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//开发</span><br><span class="line">npm run serve</span><br><span class="line"></span><br><span class="line">//构建</span><br><span class="line">npm build</span><br></pre></td></tr></table></figure><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>会话开始之初，先初始化一个只有登录路由的Vue实例，在根组件created钩子里将路由定向到登录页，用户登录成功后前端拿到用户token，设置axios实例统一为请求headers添加<code>{&quot;Authorization&quot;:token}</code>实现用户鉴权，然后获取当前用户的权限数据，主要包括路由权限和资源权限，之后动态添加路由，生成菜单，实现权限指令和全局权限验证方法，并为axios实例添加请求拦截器，至此完成权限控制初始化。动态加载路由后，路由组件将随之加载并渲染，而后展现前端界面。</p><p>为解决浏览器刷新路由重置的问题，拿到token后要将其保存到<code>sessionStorage</code>，根组件的created钩子负责检查本地是否已有token，如果有则无需登录直接用该token获取权限并初始化，如果token有效且当前路由有权访问，将加载路由组件并正确展现；若当前路由无权访问将按路由设置跳转404；如果token失效，后端应返回4xx状态码，前端统一为axios实例添加错误拦截器，遇到4xx状态码执行退出操作，清除<code>sessionStorage</code>数据并跳转到登录页，让用户重新登录。</p><h3 id="最小依赖原则"><a href="#最小依赖原则" class="headerlink" title="最小依赖原则"></a>最小依赖原则</h3><p>Vue-Access-Control的定位是单一领域解决方案，除了Vue/Vue-Router/axios之外没有其他依赖，理论上可以无障碍的应用到任何有权限控制需求的Vue项目中，项目基于<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">webpack</a> 模板开发构建，大多数新项目可以直接基于检出代码继续开发。需要说明的是，项目额外引入的<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="external">Element-UI</a>和<a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="external">CryptoJS</a>仅用于开发演示界面，他们不是必须且与权限控制毫无关系，项目应用中可以自行取舍。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">  |-- api/                  //接口文件</span><br><span class="line">  |     |-- index.js             //输出通用axios实例</span><br><span class="line">  |     |-- account.js           //按业务模块组织的接口文件，所有接口都引用./index提供的axios实例</span><br><span class="line">  |-- assets/</span><br><span class="line">  |-- components/</span><br><span class="line">  |-- router/</span><br><span class="line">  |     |-- fullpath.js         //完整路由数据，用于匹配用户的路由权限得到实际路由</span><br><span class="line">  |     `-- index.js            //输出基础路由实例</span><br><span class="line">  |-- views/</span><br><span class="line">  |-- App.vue</span><br><span class="line">  ·-- main.js</span><br></pre></td></tr></table></figure><h3 id="数据格式约定"><a href="#数据格式约定" class="headerlink" title="数据格式约定"></a>数据格式约定</h3><ul><li><p>路由权限数据必须是如下格式的对象数组，<code>id</code>和<code>parent_id</code>相同的两个路由具有上下级关系，如果希望使用自定义格式的路由数据，需要修改路由控制的相关实现，详见<a href="#路由控制"><strong>路由控制</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;菜单1&quot;,</span><br><span class="line">      &quot;parent_id&quot;: null,</span><br><span class="line">      &quot;route&quot;: &quot;route1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;菜单1-1&quot;,</span><br><span class="line">      &quot;parent_id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;route&quot;: &quot;route2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li><li><p>资源权限数据必须是如下格式的对象数组，每个对象代表一个RESTful请求，支持带参数的url，具体格式说明见<a href="#请求控制"><strong>请求控制</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2c9180895e172348015e1740805d000d&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;账号-获取&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;/accounts&quot;,</span><br><span class="line">      &quot;method&quot;: &quot;GET&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2c9180895e172348015e1740c30f000e&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;账号-删除&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;/account/**&quot;,</span><br><span class="line">      &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>路由控制包括动态注册路由和动态生成菜单两部分。</p><h3 id="动态注册路由"><a href="#动态注册路由" class="headerlink" title="动态注册路由"></a>动态注册路由</h3><p>最初实例化的路由仅包括登录和404两个路径，我们期待完整的路由是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  path: &apos;/login&apos;,</span><br><span class="line">  name: &apos;login&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/login.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;/404&apos;,</span><br><span class="line">  name: &apos;404&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/common/404.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;/&apos;,</span><br><span class="line">  name: &apos;首页&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/index.vue&apos;], resolve),</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: &apos;/route1&apos;,</span><br><span class="line">    name: &apos;栏目1&apos;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      icon: &apos;icon-channel1&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: (resolve) =&gt; require([&apos;../views/view1.vue&apos;], resolve)</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &apos;/route2&apos;,</span><br><span class="line">    name: &apos;栏目2&apos;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      icon: &apos;ico-channel2&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: (resolve) =&gt; require([&apos;../views/view2.vue&apos;], resolve),</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path: &apos;child2-1&apos;,</span><br><span class="line">      name: &apos;子栏目2-1&apos;,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      component: (resolve) =&gt; require([&apos;../views/route2-1.vue&apos;], resolve)</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;*&apos;,</span><br><span class="line">  redirect: &apos;/404&apos;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>那么接下来就需要获取首页以及其子路由们，思路是事先在本地存一份整个项目的完整路由数据，然后根据用户权限对完整路由进行筛选。</p><p>筛选的实现思路是先将后端返回的路由数据处理成如下哈希结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let hashMenus = &#123;</span><br><span class="line">   &quot;/route1&quot;:true,</span><br><span class="line">   &quot;/route1/route1-1&quot;:true,</span><br><span class="line">   &quot;/route1/route1-2&quot;:true,</span><br><span class="line">   &quot;/route2&quot;:true,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后遍历本地完整路由，在循环中将路径拼接成上述结构中的key格式，通过<code>hashMenus[route]</code>就可以判断路由是否匹配，具体实现见<code>App.vue</code>文件中的<code>getRoutes()</code>方法。</p><p>如果后端返回的路由权限数据与约定不同，就需要自行实现筛选逻辑，只要能得到实际可用的路由数据就可以，最终使用<code>addRoutes()</code>方法将他们动态添加到路由实例中，注意404页面的模糊匹配一定要放在最后。</p><h3 id="动态菜单"><a href="#动态菜单" class="headerlink" title="动态菜单"></a>动态菜单</h3><p>路由数据可以直接用来生成导航菜单，但路由数据是在根组件中得到的，导航菜单存在于<code>index.vue</code>组件中，显然我们需要通过某种方式共享菜单数据，方法有很多，一般来说首先想到的是Vuex，但菜单数据在整个用户会话过程中不会发生改变，这并不是Vuex的最佳使用场景，而且为了尽量减少不必要的依赖，这里用了最简单直接的方法，把菜单数据挂在根组件<code>data.menuData</code>上，在首页里用<code>this.$parent.menuData</code>获取。</p><p>另外，导航菜单很可能会有添加栏目图标的需求，这可以通过在路由中添加<code>meta</code>数据实现，例如将图标class或unicode存到路由meta里，模板中就可以访问到meta数据，用来生成图标标签。</p><p>在多角色系统中可能遇到的一个问题是，不同角色有一个名字相同但功能不同的路由，比如说<em>系统管理员</em>和<em>企业管理员</em>都有”账号管理”这个路由，但他们的操作权限和目标不同，实际上是两个完全不同的界面，而Vue不允许多个路由同名，因此路由的name必须做区分，但把区分后的name显示在前端菜单上会很不美观，为了让不同角色可以享有同一个菜单名称，我们只要将这两个路由的<code>meta.name</code>都设置成”账号管理”，在模板循环时优先使用<code>meta.name</code>就可以了。</p><p>菜单的具体实现可以参考<code>views/index.vue</code>。</p><h2 id="视图控制"><a href="#视图控制" class="headerlink" title="视图控制"></a>视图控制</h2><p>视图控制的目标是根据当前用户权限决定界面元素显示与否，典型场景是对各种操作按钮的显示控制。实现视图控制的本质是实现一个权限验证方法，输入请求权限，输出是否获准。然后配合<code>v-if</code>或<code>jsx</code>或自定义指令就能灵活实现各种视图控制。</p><h3 id="全局验证方法"><a href="#全局验证方法" class="headerlink" title="全局验证方法"></a>全局验证方法</h3><p>验证方法的的实现本身很简单，无非是根据后端给出的资源权限做判断，重点在于优化方法的输入输出，提升易用性，经过实践总结最终使用的方案是，将权限跟请求同时维护，验证方法接收请求对象数组为参数，返回是否具有权限的布尔值。</p><p>请求对象格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//获取账户列表</span><br><span class="line">const request = &#123;</span><br><span class="line">  p: [&apos;get,/accounts&apos;],</span><br><span class="line">  r: params =&gt; &#123;</span><br><span class="line">    return instance.get(`/accounts`, &#123;params&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>权限验证方法<code>$_has()</code>的调用格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-if=&quot;$_has([request])&quot;</span><br></pre></td></tr></table></figure><p>权限验证方法的具体实现见<code>App.vue</code>中<code>Vue.prototype.$_has</code>方法。</p><p>将权限验证方法全局混入，就可以在项目中很容易的配合<code>v-if</code>实现元素显示控制，这种方式的优点在于灵活，除了可以校验权限外，还可以在判断表达式中加入运行时状态做更多样性的判断，而且可以充分利用<code>v-if</code>响应数据变化的特点，实现动态视图控制。</p><p>具体实现细节参考<a href="//refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">基于Vue实现后台系统权限控制</a>中的相关章节。</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><code>v-if</code>的响应特性是把双刃剑，因为判断表达式在运行过程中会频繁触发，但实际上在一个用户会话周期内其权限并不会发生变化，因此如果只需要校验权限的话，用<code>v-if</code>会产生大量不必要的运算，这种情况只需在视图载入时校验一次即可，可以通过自定义指令实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//权限指令</span><br><span class="line">Vue.directive(&apos;has&apos;, &#123;</span><br><span class="line">  bind: function(el, binding) &#123;</span><br><span class="line">    if (!Vue.prototype.$_has(binding.value)) &#123;</span><br><span class="line">      el.parentNode.removeChild(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>自定义指令内部仍然是调用全局验证方法，但优点在于只会在元素初始化时执行一次，多数情况下都应该使用自定义指令实现视图控制。</p><h2 id="请求控制"><a href="#请求控制" class="headerlink" title="请求控制"></a>请求控制</h2><p>请求控制是利用axios拦截器实现的，目的是将越权请求在前端拦截掉，原理是在请求拦截器中判断本次请求是否符合用户权限，以决定是否拦截。</p><p>普通请求的判断很容易，遍历后端返回的的资源权限格式，直接判断<code>request.method</code>和<code>request.url</code>是否吻合就可以了，对于带参数的url需要使用通配符，这里需要根据项目需求前后端协商一致，约定好通配符格式后，拦截器中要先将带参数的url处理成约定格式，再判断权限，方案中已经实现了以下两种通配符格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 格式：/resources/:id</span><br><span class="line">   示例：/resources/1</span><br><span class="line">   url: /resources/**</span><br><span class="line">   解释：一个名词后跟一个参数，参数通常表示名词的id</span><br><span class="line">   </span><br><span class="line">2. 格式：/store/:id/member</span><br><span class="line">   示例：/store/1/member</span><br><span class="line">   url：/store/*/member</span><br><span class="line">   解释：两个名词之间夹带一个参数，参数通常表示第一个名词的id</span><br></pre></td></tr></table></figure><p>对于第一种格式需要注意的是，如果你要发起一个url为<code>&quot;/aaa/bbb&quot;</code>的请求，默认会被处理成<code>&quot;/aaa/**&quot;</code>进行权限校验，如果这里的”bbb”并不是参数而是url的一部分，那么你需要将url改成<code>&quot;/aaa/bbb/&quot;</code>，在最后加一个”/“表示该url不需要转化格式。</p><p>拦截器的具体实现见<code>App.vue</code>中的<code>setInterceptor()</code>方法。</p><p>如果你的项目还需要其他的通配符格式，只需要在拦截器中实现对应的检测和转化方法就可以了。</p><h2 id="演示及说明"><a href="#演示及说明" class="headerlink" title="演示及说明"></a>演示及说明</h2><h3 id="演示说明："><a href="#演示说明：" class="headerlink" title="演示说明："></a>演示说明：</h3><p>DEMO项目中演示了动态菜单、动态路由、按钮权限、请求拦截。</p><p>演示项目后端由<a href="http://rap2.taobao.org/" target="_blank" rel="external">rap2</a>生成mock数据，登录请求通常应该是POST方式，但因为rap2的编程模式无法获取到非GET的请求参数，因此只能用GET方式登录，实际项目中不建议仿效；</p><p>另外登录后获取权限的接口本来不需要携带额外参数，后端可以根据请求头携带的token信息实现用户鉴权，但因为rap2的编程模式获取不到headers数据，因此只能增加一个”Authorization”参数用于生成模拟数据。</p><h3 id="测试账号"><a href="#测试账号" class="headerlink" title="测试账号:"></a>测试账号:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. username: root</span><br><span class="line">   password: 任意</span><br><span class="line">2. username: client</span><br><span class="line">   password: 任意</span><br></pre></td></tr></table></figure><h3 id="演示地址"><a href="#演示地址" class="headerlink" title="演示地址:"></a>演示地址:</h3><p><a href="https://refined-x.com/Vue-Access-Control/">https://refined-x.com/Vue-Access-Control/</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
